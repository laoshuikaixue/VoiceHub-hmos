import { webview } from '@kit.ArkWeb';
import { window } from '@kit.ArkUI';
import { avSession } from '@kit.AVSessionKit';
import { image } from '@kit.ImageKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { http } from '@kit.NetworkKit';
import { preferences } from '@kit.ArkData';
import { WebViewSettings } from '../components/WebViewSettings';
import { DebugInfo } from '../components/DebugInfo';
import { WebLoadingProgress } from '../components/LoadingProgress';

const TAG = 'VoiceHubIndex';
const DOMAIN = 0x0000;

@Entry
@Component
struct Index {
  @State isLoading: boolean = true;
  @State loadProgress: number = 0;
  @State currentUrl: string = 'https://voicehub.lao-shui.top';
  @State isPlaying: boolean = false;
  @State showDebugInfo: boolean = false;
  @State debugMessages: string[] = [];
  @State showUrlSettings: boolean = false;
  @State inputUrl: string = '';
  @State savedUrls: string[] = [];
  @State controllerAttached: boolean = false;
  
  // æ’­æ”¾åˆ—è¡¨çŠ¶æ€
  @State currentPlaylistIndex: number = -1;
  @State playlistLength: number = 0;
  @State hasNextSong: boolean = false;
  @State hasPreviousSong: boolean = false;
  @State currentLoopMode: number = avSession.LoopMode.LOOP_MODE_SEQUENCE;
  
  // å½“å‰æ­Œæ›²ä¿¡æ¯çŠ¶æ€
  private currentTitle: string = '';
  private currentArtist: string = '';
  private currentAlbum: string = '';
  private currentCover: string = '';
  private coverCache: Map<string, image.PixelMap> = new Map();
  
  // æ’­æ”¾ä½ç½®çŠ¶æ€
  private currentPosition: number = 0;
  private currentDuration: number = 0;
  
  @State isImmersive: boolean = true;
  @State safeAreaTypes: SafeAreaType[] = [SafeAreaType.SYSTEM];
  @State safeAreaEdges: SafeAreaEdge[] = [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM];

  private webController: webview.WebviewController = new webview.WebviewController();
  private session?: avSession.AVSession;
  private isSessionActive: boolean = false;
  private dataPreferences?: preferences.Preferences;

  aboutToAppear() {
    this.addDebugMessage('ğŸš€ VoiceHub åº”ç”¨å¯åŠ¨');
    // åˆå§‹åŒ–æ•°æ®å­˜å‚¨
    this.initPreferences();
    // æ£€æŸ¥ç½‘ç»œè¿æ¥
    this.checkNetworkConnection();
    // åœ¨é¢„è§ˆæ¨¡å¼ä¸‹ä¸åˆå§‹åŒ–AVSession
    try {
      this.initAVSession();
    } catch (error) {
      hilog.warn(DOMAIN, TAG, 'Failed to initialize AVSession in preview mode');
      this.addDebugMessage('âš ï¸ é¢„è§ˆæ¨¡å¼ä¸‹è·³è¿‡AVSessionåˆå§‹åŒ–');
    }
  }

  aboutToDisappear() {
    this.releaseAVSession();
  }

  // é‡å†™è¿”å›æŒ‰é”®å¤„ç†é€»è¾‘
  onBackPress(): boolean {
    // å¦‚æœè®¾ç½®é¡µé¢å·²æ‰“å¼€ï¼Œå…ˆå…³é—­è®¾ç½®é¡µé¢
    if (this.showUrlSettings) {
      this.showUrlSettings = false;
      // this.addDebugMessage('ğŸ”™ å…³é—­è®¾ç½®é¡µé¢');
      return true;
    }
    
    // æ£€æŸ¥WebViewæ˜¯å¦å¯ä»¥è¿”å›ä¸Šä¸€é¡µ
    if (this.webController.accessBackward()) {
      this.webController.backward();
      // this.addDebugMessage('ğŸ”™ WebViewè¿”å›ä¸Šä¸€é¡µ');
      return true;
    }
    
    // å¦‚æœWebViewæ— æ³•è¿”å›ä¸”åœ¨é¦–é¡µï¼Œåˆ™æ‰“å¼€è®¾ç½®é¡µé¢
    this.showUrlSettings = true;
    // this.addDebugMessage('ğŸ”™ é¦–é¡µå·¦æ»‘æ•ˆæœï¼šæ‰“å¼€è®¾ç½®é¡µé¢');
    return true;
  }

  // æ£€æŸ¥å¹¶è®¾ç½®æ²‰æµ¸å¼æ¨¡å¼
  private checkAndSetImmersiveMode(url: string) {
    // é¢„ç•™åŠŸèƒ½ï¼šæš‚æ—¶ç¦ç”¨æ²‰æµ¸å¼æ¨¡å¼åˆ‡æ¢ï¼Œä¿æŒé»˜è®¤çš„å…¨å±æ²‰æµ¸å¼ä½“éªŒ
    return;

    /*
    const isDashboard = url.includes('/dashboard');
    const enableImmersive = !isDashboard;
    
    // å¦‚æœçŠ¶æ€æ²¡æœ‰å˜åŒ–ï¼Œåˆ™ä¸æ‰§è¡Œ
    if (this.isImmersive === enableImmersive) return;

    this.isImmersive = enableImmersive;
    
    window.getLastWindow(getContext(this)).then((win: window.Window) => {
      // è®¾ç½®æ˜¯å¦å…¨å±
      win.setWindowLayoutFullScreen(enableImmersive);
      
      if (enableImmersive) {
        // æ²‰æµ¸å¼ï¼šçŠ¶æ€æ é€æ˜
        win.setWindowSystemBarProperties({
          statusBarColor: '#00000000',
          navigationBarColor: '#00000000',
          statusBarContentColor: '#FFFFFF' 
        });
        // éšè—çŠ¶æ€æ ï¼ˆåªæ˜¾ç¤ºå¯¼èˆªæ ï¼‰
        win.setWindowSystemBarEnable(['navigation']);
        // æ¢å¤å®‰å…¨åŒºåŸŸè®¾ç½®
        this.safeAreaTypes = [SafeAreaType.SYSTEM];
        this.safeAreaEdges = [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM];
        this.addDebugMessage(`âœ¨ åˆ‡æ¢åˆ°æ²‰æµ¸æ¨¡å¼ (URL: ${url})`);
      } else {
        // éæ²‰æµ¸å¼ï¼šæ¢å¤çŠ¶æ€æ é¢œè‰²
        win.setWindowSystemBarProperties({
          statusBarColor: '#000000',
          navigationBarColor: '#000000',
          statusBarContentColor: '#FFFFFF'
        });
        // æ˜¾ç¤ºçŠ¶æ€æ å’Œå¯¼èˆªæ 
        win.setWindowSystemBarEnable(['status', 'navigation']);
        // ç¦ç”¨å®‰å…¨åŒºåŸŸè®¾ç½®ï¼Œè®©å†…å®¹ä¸å»¶ä¼¸åˆ°çŠ¶æ€æ 
        this.safeAreaTypes = [];
        this.safeAreaEdges = [];
        this.addDebugMessage(`ğŸ”³ åˆ‡æ¢åˆ°æ™®é€šæ¨¡å¼ (Dashboard URL: ${url})`);
      }
    }).catch((err: BusinessError) => {
      hilog.error(DOMAIN, TAG, `Failed to set immersive mode: ${JSON.stringify(err)}`);
    });
    */
  }

  // æ·»åŠ è°ƒè¯•ä¿¡æ¯åˆ°ç•Œé¢æ˜¾ç¤º
  private addDebugMessage(message: string): void {
    const timestamp = new Date().toLocaleTimeString();
    const fullMessage = `[${timestamp}] ${message}`;
    this.debugMessages.push(fullMessage);
    // // ä¿æŒæœ€å¤š20æ¡æ¶ˆæ¯
    // if (this.debugMessages.length > 20) {
    //   this.debugMessages.shift();
    // }
    hilog.info(DOMAIN, TAG, message);
  }

  // æ¸…é™¤è°ƒè¯•ä¿¡æ¯
  private clearDebugMessages(): void {
    this.debugMessages = [];
  }

  // åˆå§‹åŒ–æ•°æ®å­˜å‚¨
  private async initPreferences(): Promise<void> {
    try {
      this.dataPreferences = await preferences.getPreferences(getContext(this), 'voicehub_settings');
      await this.loadSavedUrls();
      await this.loadCurrentUrl();
      this.addDebugMessage('âœ… æ•°æ®å­˜å‚¨åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      this.addDebugMessage(`âŒ æ•°æ®å­˜å‚¨åˆå§‹åŒ–å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // åŠ è½½ä¿å­˜çš„URLåˆ—è¡¨
  private async loadSavedUrls(): Promise<void> {
    try {
      if (this.dataPreferences) {
        const urls = await this.dataPreferences.get('saved_urls', '[]') as string;
        this.savedUrls = JSON.parse(urls);
        this.addDebugMessage(`ğŸ“‹ åŠ è½½äº† ${this.savedUrls.length} ä¸ªä¿å­˜çš„URL`);
      }
    } catch (error) {
      this.addDebugMessage(`âŒ åŠ è½½URLåˆ—è¡¨å¤±è´¥: ${JSON.stringify(error)}`);
      this.savedUrls = [];
    }
  }

  // åŠ è½½å½“å‰URL
  private async loadCurrentUrl(): Promise<void> {
    try {
      if (this.dataPreferences) {
        const savedUrl = await this.dataPreferences.get('current_url', this.currentUrl) as string;
        this.currentUrl = savedUrl;
        this.inputUrl = savedUrl;
        
        // é¢„è¿æ¥å½“å‰URLï¼ŒåŠ é€Ÿé¡µé¢åŠ è½½
        try {
          webview.WebviewController.prepareForPageLoad(this.currentUrl, true, 2);
          this.addDebugMessage(`ğŸš€ é¢„è¿æ¥URL: ${this.currentUrl}`);
        } catch (err) {
          hilog.warn(DOMAIN, TAG, `Failed to prepare for page load: ${JSON.stringify(err)}`);
        }
        
        this.addDebugMessage(`ğŸŒ åŠ è½½å½“å‰URL: ${this.currentUrl}`);
      }
    } catch (error) {
      this.addDebugMessage(`âŒ åŠ è½½å½“å‰URLå¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // ä¿å­˜URLåˆ°åˆ—è¡¨
  private async saveUrl(url: string): Promise<void> {
    try {
      if (!url.trim()) return;
      
      // éªŒè¯URLæ ¼å¼
      let processedUrl = url.trim();
      if (!processedUrl.startsWith('http://') && !processedUrl.startsWith('https://')) {
        processedUrl = 'https://' + processedUrl;
      }
      
      // é¿å…é‡å¤
      if (!this.savedUrls.includes(processedUrl)) {
        this.savedUrls.unshift(processedUrl);
        // æœ€å¤šä¿å­˜10ä¸ªURL
        if (this.savedUrls.length > 10) {
          this.savedUrls = this.savedUrls.slice(0, 10);
        }
        
        if (this.dataPreferences) {
          await this.dataPreferences.put('saved_urls', JSON.stringify(this.savedUrls));
          await this.dataPreferences.flush();
        }
        this.addDebugMessage(`ğŸ’¾ URLå·²ä¿å­˜åˆ°åˆ—è¡¨: ${processedUrl}`);
      } else {
        this.addDebugMessage(`â„¹ï¸ URLå·²å­˜åœ¨äºåˆ—è¡¨ä¸­: ${processedUrl}`);
      }
      
      // æ³¨æ„ï¼šä¸åœ¨è¿™é‡Œæ›´æ–°currentUrlï¼Œè®©è°ƒç”¨æ–¹å†³å®šæ˜¯å¦è¦åŠ è½½
      
    } catch (error) {
      this.addDebugMessage(`âŒ ä¿å­˜URLå¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // åˆ é™¤ä¿å­˜çš„URL
  private async deleteUrl(url: string): Promise<void> {
    try {
      const index = this.savedUrls.indexOf(url);
      if (index > -1) {
        this.savedUrls.splice(index, 1);
        if (this.dataPreferences) {
          await this.dataPreferences.put('saved_urls', JSON.stringify(this.savedUrls));
          await this.dataPreferences.flush();
        }
        this.addDebugMessage(`ğŸ—‘ï¸ URLå·²åˆ é™¤: ${url}`);
      }
    } catch (error) {
      this.addDebugMessage(`âŒ åˆ é™¤URLå¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // æ£€æŸ¥ç½‘ç»œè¿æ¥
  private async checkNetworkConnection(): Promise<void> {
    try {
      this.addDebugMessage('ğŸ” æ£€æŸ¥ç½‘ç»œè¿æ¥...');
      
      const httpRequest = http.createHttp();
      const testUrl = this.currentUrl;
      
      httpRequest.request(testUrl, {
        method: http.RequestMethod.GET,
        connectTimeout: 5000,
        readTimeout: 5000,
        header: {
          'User-Agent': 'VoiceHub-HarmonyOS/1.0.0'
        }
      }).then((response) => {
        if (response.responseCode === 200) {
          this.addDebugMessage('âœ… ç½‘ç»œè¿æ¥æ­£å¸¸ï¼ŒæœåŠ¡å™¨å¯è®¿é—®');
        } else {
          this.addDebugMessage(`âš ï¸ æœåŠ¡å™¨å“åº”å¼‚å¸¸: ${response.responseCode}`);
        }
        httpRequest.destroy();
      }).catch((error: BusinessError) => {
        this.addDebugMessage(`âŒ ç½‘ç»œè¿æ¥å¤±è´¥: ${JSON.stringify(error)}`);
        this.addDebugMessage('ğŸ’¡ è¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®æˆ–æœåŠ¡å™¨çŠ¶æ€');
        httpRequest.destroy();
      });
    } catch (error) {
      this.addDebugMessage(`âŒ ç½‘ç»œæ£€æŸ¥å¼‚å¸¸: ${JSON.stringify(error)}`);
    }
  }

  // åˆå§‹åŒ–AVSession
  private async initAVSession(): Promise<void> {
    try {
      this.session = await avSession.createAVSession(getContext(this), 'VoiceHub', 'audio');
      hilog.info(DOMAIN, TAG, 'AVSession created successfully');
      
      // æ³¨å†Œæ§åˆ¶å‘½ä»¤ç›‘å¬å™¨
      this.session.on('play', this.handleSystemPlay.bind(this));
      this.session.on('pause', this.handleSystemPause.bind(this));
      this.session.on('stop', this.handleSystemStop.bind(this));
      this.session.on('playNext', this.handleSystemNext.bind(this));
      this.session.on('playPrevious', this.handleSystemPrevious.bind(this));
      this.session.on('seek', this.handleSystemSeek.bind(this));
      this.session.on('setLoopMode', this.handleSystemLoopMode.bind(this));
      
      hilog.info(DOMAIN, TAG, 'AVSession control listeners registered successfully');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to create AVSession: ${JSON.stringify(error)}`);
    }
  }

  // æ¿€æ´»AVSessionï¼ˆä»…åœ¨å¼€å§‹æ’­æ”¾æ—¶è°ƒç”¨ï¼‰
  private async activateAVSession(): Promise<void> {
    if (!this.session || this.isSessionActive) return;
    
    try {
      await this.session.activate();
      this.isSessionActive = true;
      hilog.info(DOMAIN, TAG, 'AVSession activated');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to activate AVSession: ${JSON.stringify(error)}`);
    }
  }

  // åœç”¨AVSessionï¼ˆåœ¨åœæ­¢æ’­æ”¾æ—¶è°ƒç”¨ï¼‰
  private async deactivateAVSession(): Promise<void> {
    if (!this.session || !this.isSessionActive) return;
    
    try {
      await this.session.deactivate();
      this.isSessionActive = false;
      hilog.info(DOMAIN, TAG, 'AVSession deactivated');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to deactivate AVSession: ${JSON.stringify(error)}`);
    }
  }

  // ç³»ç»Ÿæ§åˆ¶å‘½ä»¤å¤„ç† - é€šè¿‡WebViewä¸ç½‘é¡µæ’­æ”¾å™¨äº¤äº’
  private handleSystemPlay() {
    // this.addDebugMessage('â–¶ï¸ ç³»ç»Ÿæ§åˆ¶: æ’­æ”¾');
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨æ’­æ”¾
    this.webController.runJavaScript(`
      if (window.voiceHubPlayer && window.voiceHubPlayer.play) {
        window.voiceHubPlayer.play();
      }
    `);
  }

  private handleSystemPause() {
    // this.addDebugMessage('â¸ï¸ ç³»ç»Ÿæ§åˆ¶: æš‚åœ');
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨æš‚åœ
    this.webController.runJavaScript(`
      if (window.voiceHubPlayer && window.voiceHubPlayer.pause) {
        window.voiceHubPlayer.pause();
      }
    `);
  }

  private handleSystemStop() {
    // this.addDebugMessage('â¹ï¸ ç³»ç»Ÿæ§åˆ¶: åœæ­¢');
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨åœæ­¢
    this.webController.runJavaScript(`
      if (window.voiceHubPlayer && window.voiceHubPlayer.stop) {
        window.voiceHubPlayer.stop();
      }
    `);
  }

  private handleSystemNext() {
    if (!this.hasNextSong) {
      // this.addDebugMessage('â­ï¸ ç³»ç»Ÿæ§åˆ¶: ä¸‹ä¸€é¦– (å·²ç¦ç”¨ - æ²¡æœ‰ä¸‹ä¸€é¦–)');
      return;
    }

    // this.addDebugMessage('â­ï¸ ç³»ç»Ÿæ§åˆ¶: ä¸‹ä¸€é¦–');
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨ä¸‹ä¸€é¦–
    this.webController.runJavaScript(`
      if (window.voiceHubPlayer && window.voiceHubPlayer.next) {
        window.voiceHubPlayer.next();
      }
    `);
  }

  private handleSystemPrevious() {
    if (!this.hasPreviousSong) {
      // this.addDebugMessage('â®ï¸ ç³»ç»Ÿæ§åˆ¶: ä¸Šä¸€é¦– (å·²ç¦ç”¨ - æ²¡æœ‰ä¸Šä¸€é¦–)');
      return;
    }

    // this.addDebugMessage('â®ï¸ ç³»ç»Ÿæ§åˆ¶: ä¸Šä¸€é¦–');
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨ä¸Šä¸€é¦–
    this.webController.runJavaScript(`
      if (window.voiceHubPlayer && window.voiceHubPlayer.previous) {
        window.voiceHubPlayer.previous();
      }
    `);
  }

  private handleSystemSeek(time: number) {
    // ... existing implementation
    const timeInSeconds = time / 1000;
    // this.addDebugMessage(`â© ç³»ç»Ÿæ§åˆ¶: è·³è½¬åˆ° ${timeInSeconds.toFixed(1)}s (åŸå§‹: ${time}ms)`);
    
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨è·³è½¬è¿›åº¦ï¼ˆä¼ é€’ç§’æ•°ï¼‰
    this.webController.runJavaScript(`
      try {
        const targetTime = ${timeInSeconds};
        console.log('VoiceHub: Seeking to', targetTime, 'seconds');
        
        if (window.voiceHubPlayer && window.voiceHubPlayer.seek) {
          window.voiceHubPlayer.seek(targetTime);
        } else if (window.audioPlayerInstance && window.audioPlayerInstance.seekToTime) {
          window.audioPlayerInstance.seekToTime(targetTime);
        } else {
          console.warn('VoiceHub: No seek method available');
        }
      } catch (error) {
        console.error('VoiceHub: Seek error:', error);
      }
    `);
  }

  private handleSystemLoopMode(mode: number) {
    // this.addDebugMessage(`ğŸ”„ ç³»ç»Ÿæ§åˆ¶: æ”¶åˆ°å¾ªç¯æ¨¡å¼åˆ‡æ¢è¯·æ±‚ ${mode}`);
    
    // å‚è€ƒ Melotopia é¡¹ç›®çš„ AVSessionUtils.ets å®ç°
    // é‡æ–°æ˜ å°„å¾ªç¯æ¨¡å¼ï¼Œå®ç°è‡ªå®šä¹‰çš„åˆ‡æ¢é€»è¾‘
    // HarmonyOS: 0=SEQUENCE, 1=SINGLE, 2=LIST, 3=SHUFFLE
    let targetMode = mode;
    
    // è‡ªå®šä¹‰å¾ªç¯é€»è¾‘: 0->1, 1->2, 2->3, 3->0
    // ä½†ç”±äºWebç«¯å¯èƒ½ä¸æ”¯æŒ 3(SHUFFLE) ä½œä¸ºLoopModeï¼Œæˆ–è€…æœ‰ä¸åŒçš„æ˜ å°„
    // æˆ‘ä»¬è¿™é‡Œå…ˆæŒ‰ç…§ Melotopia çš„é€»è¾‘è¿›è¡Œæ˜ å°„ï¼Œç¡®ä¿æŒç»­åˆ‡æ¢
    if (mode === avSession.LoopMode.LOOP_MODE_SEQUENCE) {
      targetMode = avSession.LoopMode.LOOP_MODE_SINGLE;
    } else if (mode === avSession.LoopMode.LOOP_MODE_SINGLE) {
      targetMode = avSession.LoopMode.LOOP_MODE_LIST;
    } else if (mode === avSession.LoopMode.LOOP_MODE_LIST) {
      // å¦‚æœWebç«¯æ”¯æŒéšæœºæ’­æ”¾(3)ï¼Œåˆ™åˆ‡æ¢åˆ°3ï¼Œå¦åˆ™å›åˆ°0
      // è¿™é‡Œçš„ 3 åœ¨Webç«¯ä¼šè¢«æ˜ å°„ä¸º 'order'ï¼Œå¯èƒ½ä¼šå¯¼è‡´ Systemæ˜¾ç¤º3 -> Webè®¾ä¸º2 -> Webå›ä¼ 2 -> Systemæ˜¾ç¤º2 çš„æƒ…å†µ
      // ä½†ä¸ºäº†å“åº”ç‚¹å‡»ï¼Œæˆ‘ä»¬è¿˜æ˜¯åˆ‡æ¢åˆ° 3 (å¦‚æœæ”¯æŒ) æˆ–è€… 0
      targetMode = avSession.LoopMode.LOOP_MODE_SHUFFLE; 
    } else {
      targetMode = avSession.LoopMode.LOOP_MODE_SEQUENCE;
    }
    
    // å¦‚æœ Web ç«¯ç¡®å®ä¸æ”¯æŒ Shuffle (3) ä½œä¸º LoopMode (é€šå¸¸ Shuffle æ˜¯å•ç‹¬çš„å¼€å…³)
    // æˆ‘ä»¬å¯ä»¥è·³è¿‡ 3: 2 -> 0
    // ä¿®æ”¹ä¸º: 0->1, 1->2, 2->0 (ä¸‰æ€å¾ªç¯)
    if (mode === avSession.LoopMode.LOOP_MODE_LIST) {
       targetMode = avSession.LoopMode.LOOP_MODE_SEQUENCE;
    } else if (mode === avSession.LoopMode.LOOP_MODE_SHUFFLE) {
       targetMode = avSession.LoopMode.LOOP_MODE_SEQUENCE;
    }

    // this.addDebugMessage(`ğŸ”„ æ˜ å°„å¾ªç¯æ¨¡å¼: ${mode} -> ${targetMode}`);
    this.currentLoopMode = targetMode;
    
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨åˆ‡æ¢å¾ªç¯æ¨¡å¼
    this.webController.runJavaScript(`
      try {
        const loopMode = ${targetMode};
        
        // ç­–ç•¥1: ä¼˜å…ˆè°ƒç”¨ voiceHubPlayer.setLoopMode (é€šå¸¸ç”± useAudioPlayerSync ç»‘å®š)
        if (window.voiceHubPlayer && window.voiceHubPlayer.setLoopMode) {
          window.voiceHubPlayer.setLoopMode(loopMode);
        } 
        // ç­–ç•¥2: è°ƒç”¨ voiceHubPlayerInstance.setPlayMode (å¤‡ç”¨)
        else if (window.voiceHubPlayerInstance && window.voiceHubPlayerInstance.setPlayMode) {
          window.voiceHubPlayerInstance.setPlayMode(loopMode);
        }
        // ç­–ç•¥3: äº‹ä»¶åˆ†å‘ (ä¿åº•)
        else {
          window.dispatchEvent(new CustomEvent('harmonyos-set-loop-mode', { detail: { mode: loopMode } }));
        }
      } catch (error) {
        console.error('VoiceHub: Set loop mode error:', error);
      }
    `);
    
    // ç«‹å³æ›´æ–°AVSessionçŠ¶æ€
    if (this.session) {
      this.updateLoopModeOnly();
    }
  }

  private releaseAVSession() {
    if (this.session) {
      this.session.deactivate();
      this.session.destroy();
      this.session = undefined;
      this.isSessionActive = false;
    }
  }

  // WebViewé¡µé¢åŠ è½½å®Œæˆ
  private onPageEnd() {
    this.isLoading = false;
    this.addDebugMessage(`ğŸŒ é¡µé¢åŠ è½½å®Œæˆ: ${this.currentUrl}`);
    
    // æ³¨å…¥åŸç”Ÿæ¥å£åˆ°WebViewï¼Œå»ºç«‹åŒå‘é€šä¿¡æ¡¥æ¢
    const jsCode = `
      // åˆ›å»ºHarmonyOSåŸç”Ÿæ¥å£å¯¹è±¡
      window.HarmonyOS = {
        // è°ƒç”¨åŸç”Ÿæ–¹æ³•
        callNative: function(method, parameters) {
          try {
            const message = JSON.stringify({ method: method, parameters: parameters });
            if (window.harmonyos && window.harmonyos.onMessage) {
              window.harmonyos.onMessage(message);
            }
          } catch (error) {
            console.error('Failed to call native method:', error);
          }
        },
        
        // å‘é€æ¶ˆæ¯åˆ°åŸç”Ÿä¾§ï¼ˆä¸callNativeåŠŸèƒ½ç›¸åŒï¼Œæä¾›å…¼å®¹æ€§ï¼‰
        postMessage: function(message) {
          try {
            if (window.harmonyos && window.harmonyos.onMessage) {
              window.harmonyos.onMessage(message);
            }
          } catch (error) {
            console.error('Failed to post message to native:', error);
          }
        }
      };
      
      // ç¡®ä¿ voiceHubPlayer å¯¹è±¡å­˜åœ¨
      window.voiceHubPlayer = window.voiceHubPlayer || {};
      
      // æ›´æ–° Native é€šä¿¡å›è°ƒ (æ€»æ˜¯æ›´æ–°ä»¥ç¡®ä¿é€šä¿¡æ­£å¸¸)
      window.voiceHubPlayer.onPlayStateChanged = function(isPlaying, songInfo) {
          // console.log('VoiceHub: Play state changed', isPlaying, songInfo);
          window.HarmonyOS.callNative('updatePlayState', {
            isPlaying: isPlaying,
            title: songInfo.title || '',
            artist: songInfo.artist || '',
            album: songInfo.album || '',
            cover: songInfo.cover || '',
            duration: songInfo.duration || 0,
            position: songInfo.position || 0,
            loopMode: songInfo.loopMode // æ¥æ”¶å¾ªç¯æ¨¡å¼
          });
      };
      
      window.voiceHubPlayer.onSongChanged = function(songInfo) {
          // console.log('VoiceHub: Song changed', songInfo);
          window.HarmonyOS.callNative('updateMetadata', {
            title: songInfo.title || '',
            artist: songInfo.artist || '',
            album: songInfo.album || '',
            cover: songInfo.cover || '',
            duration: songInfo.duration || 0,
            lyrics: songInfo.lyrics || ''
          });
      };
      
      window.voiceHubPlayer.updatePlaylistState = function(playlistState) {
          // console.log('VoiceHub: Playlist state update received:', playlistState);
          // é€šè¿‡WebViewæ¶ˆæ¯æœºåˆ¶å‘é€åˆ°é¸¿è’™ä¾§
          if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.webViewHandler) {
            window.webkit.messageHandlers.webViewHandler.postMessage(JSON.stringify({
              method: 'updatePlaylistState',
              parameters: playlistState
            }));
          }
      };
      
      window.voiceHubPlayer.updateLyrics = function(lyrics) {
          // console.log('VoiceHub: Lyrics update received, length:', lyrics ? lyrics.length : 0);
          // é€šè¿‡WebViewæ¶ˆæ¯æœºåˆ¶å‘é€åˆ°é¸¿è’™ä¾§
          window.HarmonyOS.callNative('updateLyrics', {
            lyrics: lyrics || ''
          });
      };

      // ä¸ºç½‘é¡µæ’­æ”¾å™¨æä¾›ç³»ç»Ÿæ§åˆ¶æ¥å£ (ä»…å½“ä¸å­˜åœ¨æ—¶èµ‹å€¼ï¼Œä¼˜å…ˆä¿ç•™ Vue ç»„ä»¶ç»‘å®šçš„ä¸“ç”¨ç‰ˆæœ¬)
      
      if (!window.voiceHubPlayer.play) {
        window.voiceHubPlayer.play = function() {
          console.log('VoiceHub: System play command received');
          
          // æ–¹æ¡ˆ1: ç›´æ¥è°ƒç”¨å…¨å±€æ’­æ”¾å™¨å®ä¾‹
          if (window.voiceHubPlayerInstance && window.voiceHubPlayerInstance.play) {
            console.log('VoiceHub: Using direct player instance for play');
            window.voiceHubPlayerInstance.play();
            return;
          }
          
          // æ–¹æ¡ˆ2: æŸ¥æ‰¾å¹¶ç›´æ¥æ“ä½œéŸ³é¢‘å…ƒç´ 
          const audioElements = document.querySelectorAll('audio');
          if (audioElements.length > 0) {
            console.log('VoiceHub: Found audio elements, attempting direct play');
            for (let audio of audioElements) {
              if (audio.src && !audio.paused === false) {
                audio.play().catch(e => console.warn('Direct audio play failed:', e));
                break;
              }
            }
          }
          
          // æ–¹æ¡ˆ3: ä½¿ç”¨windowäº‹ä»¶åˆ†å‘æœºåˆ¶
          window.dispatchEvent(new CustomEvent('harmonyos-play'));
          
          // æ–¹æ¡ˆ4: å°è¯•Nuxtäº‹ä»¶æ€»çº¿
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-play');
          }
          
          // æ–¹æ¡ˆ5: å°è¯•Vueåº”ç”¨å®ä¾‹äº‹ä»¶
          if (window.$nuxt && window.$nuxt.$emit) {
            window.$nuxt.$emit('harmonyos-play');
          }
        };
      }
      
      if (!window.voiceHubPlayer.pause) {
        window.voiceHubPlayer.pause = function() {
          console.log('VoiceHub: System pause command received');
          
          // æ–¹æ¡ˆ1: ç›´æ¥è°ƒç”¨å…¨å±€æ’­æ”¾å™¨å®ä¾‹
          if (window.voiceHubPlayerInstance && window.voiceHubPlayerInstance.pause) {
            console.log('VoiceHub: Using direct player instance for pause');
            window.voiceHubPlayerInstance.pause();
            return;
          }
          
          // æ–¹æ¡ˆ2: æŸ¥æ‰¾å¹¶ç›´æ¥æ“ä½œéŸ³é¢‘å…ƒç´ 
          const audioElements = document.querySelectorAll('audio');
          if (audioElements.length > 0) {
            console.log('VoiceHub: Found audio elements, attempting direct pause');
            for (let audio of audioElements) {
              if (audio.src && !audio.paused) {
                audio.pause();
                break;
              }
            }
          }
          
          // æ–¹æ¡ˆ3: ä½¿ç”¨windowäº‹ä»¶åˆ†å‘æœºåˆ¶
          window.dispatchEvent(new CustomEvent('harmonyos-pause'));
          
          // æ–¹æ¡ˆ4: å°è¯•Nuxtäº‹ä»¶æ€»çº¿
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-pause');
          }
          
          // æ–¹æ¡ˆ5: å°è¯•Vueåº”ç”¨å®ä¾‹äº‹ä»¶
          if (window.$nuxt && window.$nuxt.$emit) {
            window.$nuxt.$emit('harmonyos-pause');
          }
        };
      }
      
      if (!window.voiceHubPlayer.stop) {
        window.voiceHubPlayer.stop = function() {
          console.log('VoiceHub: System stop command received');
          
          // æ–¹æ¡ˆ1: ç›´æ¥è°ƒç”¨å…¨å±€æ’­æ”¾å™¨å®ä¾‹
          if (window.voiceHubPlayerInstance && window.voiceHubPlayerInstance.stop) {
            console.log('VoiceHub: Using direct player instance for stop');
            window.voiceHubPlayerInstance.stop();
            return;
          }
          
          // æ–¹æ¡ˆ2: æŸ¥æ‰¾å¹¶ç›´æ¥æ“ä½œéŸ³é¢‘å…ƒç´ 
          const audioElements = document.querySelectorAll('audio');
          if (audioElements.length > 0) {
            console.log('VoiceHub: Found audio elements, attempting direct stop');
            for (let audio of audioElements) {
              if (audio.src) {
                audio.pause();
                audio.currentTime = 0;
                break;
              }
            }
          }
          
          // æ–¹æ¡ˆ3: ä½¿ç”¨windowäº‹ä»¶åˆ†å‘æœºåˆ¶
          window.dispatchEvent(new CustomEvent('harmonyos-stop'));
          
          // æ–¹æ¡ˆ4: å°è¯•Nuxtäº‹ä»¶æ€»çº¿
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-stop');
          }
          
          // æ–¹æ¡ˆ5: å°è¯•Vueåº”ç”¨å®ä¾‹äº‹ä»¶
          if (window.$nuxt && window.$nuxt.$emit) {
            window.$nuxt.$emit('harmonyos-stop');
          }
        };
      }
      
      if (!window.voiceHubPlayer.next) {
        window.voiceHubPlayer.next = function() {
          console.log('VoiceHub: System next command received');
          
          // ä½¿ç”¨windowäº‹ä»¶åˆ†å‘æœºåˆ¶
          window.dispatchEvent(new CustomEvent('harmonyos-next'));
          
          // å°è¯•Nuxtäº‹ä»¶æ€»çº¿
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-next');
          }
          
          // å°è¯•Vueåº”ç”¨å®ä¾‹äº‹ä»¶
          if (window.$nuxt && window.$nuxt.$emit) {
            window.$nuxt.$emit('harmonyos-next');
          }
        };
      }
      
      if (!window.voiceHubPlayer.previous) {
        window.voiceHubPlayer.previous = function() {
          console.log('VoiceHub: System previous command received');
          
          // ä½¿ç”¨windowäº‹ä»¶åˆ†å‘æœºåˆ¶
          window.dispatchEvent(new CustomEvent('harmonyos-previous'));
          
          // å°è¯•Nuxtäº‹ä»¶æ€»çº¿
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-previous');
          }
          
          // å°è¯•Vueåº”ç”¨å®ä¾‹äº‹ä»¶
          if (window.$nuxt && window.$nuxt.$emit) {
            window.$nuxt.$emit('harmonyos-previous');
          }
        };
      }
      
      if (!window.voiceHubPlayer.seek) {
        window.voiceHubPlayer.seek = function(time) {
          console.log('VoiceHub: System seek command received, time:', time);
          
          // æ–¹æ¡ˆ1: ç›´æ¥è°ƒç”¨å…¨å±€æ’­æ”¾å™¨å®ä¾‹
          if (window.voiceHubPlayerInstance && window.voiceHubPlayerInstance.seek) {
            console.log('VoiceHub: Using direct player instance for seek');
            window.voiceHubPlayerInstance.seek(time);
            return;
          }
          
          // æ–¹æ¡ˆ2: æŸ¥æ‰¾å¹¶ç›´æ¥æ“ä½œéŸ³é¢‘å…ƒç´ 
          const audioElements = document.querySelectorAll('audio');
          if (audioElements.length > 0) {
            console.log('VoiceHub: Found audio elements, attempting direct seek');
            for (let audio of audioElements) {
              if (audio.src && audio.duration > 0) {
                audio.currentTime = Math.min(time, audio.duration);
                break;
              }
            }
          }
          
          // æ–¹æ¡ˆ3: ä½¿ç”¨windowäº‹ä»¶åˆ†å‘æœºåˆ¶
          window.dispatchEvent(new CustomEvent('harmonyos-seek', { detail: { time: time } }));
          
          // æ–¹æ¡ˆ4: å°è¯•Nuxtäº‹ä»¶æ€»çº¿
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-seek', { time: time });
          }
          
          // æ–¹æ¡ˆ5: å°è¯•Vueåº”ç”¨å®ä¾‹äº‹ä»¶
          if (window.$nuxt && window.$nuxt.$emit) {
            window.$nuxt.$emit('harmonyos-seek', { time: time });
          }
        };
      }
      
      if (!window.voiceHubPlayer.setLoopMode) {
        window.voiceHubPlayer.setLoopMode = function(mode) {
          console.log('VoiceHub: System setLoopMode command received, mode:', mode);
          
          // æ–¹æ¡ˆ1: ç›´æ¥è°ƒç”¨å…¨å±€æ’­æ”¾å™¨å®ä¾‹
          if (window.voiceHubPlayerInstance && window.voiceHubPlayerInstance.setPlayMode) {
             window.voiceHubPlayerInstance.setPlayMode(mode);
             return;
          }
          
          // æ–¹æ¡ˆ2: ä½¿ç”¨windowäº‹ä»¶åˆ†å‘æœºåˆ¶
          window.dispatchEvent(new CustomEvent('harmonyos-set-loop-mode', { detail: { mode: mode } }));
        };
      }
      
      console.log('VoiceHub HarmonyOS bridge initialized');

      // ç›‘å¬ SPA è·¯ç”±å˜åŒ–
      (function() {
        var pushState = history.pushState;
        var replaceState = history.replaceState;

        history.pushState = function() {
          pushState.apply(history, arguments);
          window.HarmonyOS.callNative('urlChange', { url: window.location.href });
        };

        history.replaceState = function() {
          replaceState.apply(history, arguments);
          window.HarmonyOS.callNative('urlChange', { url: window.location.href });
        };

        window.addEventListener('popstate', function() {
          window.HarmonyOS.callNative('urlChange', { url: window.location.href });
        });
      })();
    `;
    
    this.webController.runJavaScript(jsCode);
  }

  // å¤„ç†æ¥è‡ªWebViewçš„æ¶ˆæ¯
  private onMessage(message: string): void {
    try {
      const data: Record<string, ESObject> = JSON.parse(message) as Record<string, ESObject>;
      const method = data.method as string;
      
      // é¿å…æ—¥å¿—åˆ·å±ï¼Œä»…åœ¨éä½ç½®æ›´æ–°æ—¶è¾“å‡ºæ—¥å¿—
      if (method !== 'positionUpdate' && method !== 'log') {
         hilog.info(DOMAIN, TAG, `Received message from WebView: ${method}`);
      }
      
      const parameters = data.parameters as Record<string, ESObject>;
      
      switch (method) {
        case 'updatePlayState':
          // æ’­æ”¾çŠ¶æ€æ›´æ–°
          if (parameters && typeof parameters.isPlaying === 'boolean') {
            const position = parameters.position as number;
            const duration = parameters.duration as number;
            const loopMode = parameters.loopMode as number | undefined;
            
            // åªæ›´æ–°æ’­æ”¾çŠ¶æ€ï¼Œä¸è§¦å‘å…ƒæ•°æ®æ›´æ–°
            this.updatePlayState(parameters.isPlaying as boolean, position, duration, loopMode);
          }
          break;
        case 'updateMetadata':
          // æ­Œæ›²åˆ‡æ¢ - éœ€è¦æ›´æ–°å…ƒæ•°æ®å’Œé‡ç½®æ’­æ”¾çŠ¶æ€
          if (parameters) {
            this.updateMetadata(parameters);
          }
          break;
        case 'updatePlaylistState':
          // æ’­æ”¾åˆ—è¡¨æ›´æ–° - åªæ›´æ–°åˆ—è¡¨çŠ¶æ€ï¼Œä¸å½±å“å½“å‰æ’­æ”¾
          if (parameters) {
            this.updatePlaylistState(parameters).catch((error: Error | BusinessError) => {
              hilog.error(DOMAIN, TAG, `Failed to update playlist state: ${JSON.stringify(error)}`);
            });
          }
          break;
        case 'positionUpdate':
          // æ’­æ”¾ä½ç½®æ›´æ–°
          if (parameters && typeof parameters.position === 'number') {
            this.handlePositionUpdate(parameters);
          }
          break;
        case 'updateLyrics':
          // æ­Œè¯æ›´æ–°
          if (parameters) {
            this.handleLyricsUpdate(parameters);
          }
          break;
        case 'urlChange':
          // URL å˜åŒ–
          if (parameters && parameters.url) {
            const url = parameters.url as string;
            this.checkAndSetImmersiveMode(url);
          }
          break;
        case 'log':
          // å‰ç«¯æ—¥å¿—
          if (parameters && parameters.message) {
            // this.addDebugMessage(`ğŸ–¥ï¸ å‰ç«¯æ—¥å¿—: ${parameters.message}`);
          }
          break;
        default:
          hilog.warn(DOMAIN, TAG, `Unknown method: ${method}`);
      }
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Error parsing WebView message: ${error}`);
    }
  }

  // å¤„ç†æ’­æ”¾ä½ç½®æ›´æ–°
  private handlePositionUpdate(params: Record<string, ESObject>): void {
    try {
      const position = params.position as number;
      if (position !== undefined && position >= 0) {
        this.currentPosition = position;
        
        // åªæ›´æ–°ä½ç½®ä¿¡æ¯ï¼Œä¸æ”¹å˜æ’­æ”¾çŠ¶æ€
        if (this.session && this.isSessionActive) {
          this.updatePositionOnly(position);
        }
      }
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to handle position update: ${JSON.stringify(error)}`);
    }
  }

  // å¤„ç†æ­Œè¯æ›´æ–°
  private async handleLyricsUpdate(params: Record<string, ESObject>): Promise<void> {
    try {
      const lyrics = params.lyrics as string;
      
      if (!this.session) {
        return;
      }
      
      // åªæ›´æ–°æ­Œè¯ï¼Œä¿æŒå…¶ä»–å…ƒæ•°æ®ä¸å˜
      await this.updateLyricsOnly(lyrics || '');
      
      hilog.info(DOMAIN, TAG, `Lyrics updated: ${lyrics ? lyrics.length : 0} characters`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to handle lyrics update: ${JSON.stringify(error)}`);
    }
  }

  // ä»…æ›´æ–°æ’­æ”¾ä½ç½®ï¼Œä¸å½±å“å…¶ä»–çŠ¶æ€
  private async updatePositionOnly(positionInSeconds: number): Promise<void> {
    if (!this.session) return;
    
    try {
      // ä¼˜å…ˆä½¿ç”¨å½“å‰ä¿å­˜çš„å¾ªç¯æ¨¡å¼
      let loopMode = this.currentLoopMode;
      
      // å¦‚æœæ²¡æœ‰è®¾ç½®è¿‡å¾ªç¯æ¨¡å¼ï¼Œåˆ™æ ¹æ®æ’­æ”¾åˆ—è¡¨çŠ¶æ€æ¨æ–­
      if (loopMode === undefined) {
        loopMode = avSession.LoopMode.LOOP_MODE_SEQUENCE;
        if (this.playlistLength <= 1) {
          loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
        } else if (!this.hasNextSong && !this.hasPreviousSong) {
          loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
        }
      }

      // ä¿æŒå½“å‰æ’­æ”¾çŠ¶æ€ï¼Œåªæ›´æ–°ä½ç½®
      const playbackState: avSession.AVPlaybackState = {
        state: this.isPlaying ? avSession.PlaybackState.PLAYBACK_STATE_PLAY : avSession.PlaybackState.PLAYBACK_STATE_PAUSE,
        loopMode: loopMode,
        isFavorite: false,
        position: {
          elapsedTime: Math.floor(positionInSeconds * 1000), // è½¬æ¢ä¸ºæ¯«ç§’
          updateTime: Date.now()
        }
      };
      
      await this.session.setAVPlaybackState(playbackState);
      hilog.info(DOMAIN, TAG, `Position updated: ${positionInSeconds.toFixed(1)}s, loopMode: ${loopMode}`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update position only: ${JSON.stringify(error)}`);
    }
  }

  // æ›´æ–°æ’­æ”¾åˆ—è¡¨çŠ¶æ€
  private async updatePlaylistState(params: Record<string, ESObject>): Promise<void> {
    try {
      const oldHasNext = this.hasNextSong;
      const oldHasPrevious = this.hasPreviousSong;
      const oldLoopMode = this.currentLoopMode;
      
      this.currentPlaylistIndex = (params.currentIndex as number) || -1;
      this.playlistLength = (params.playlistLength as number) || 0;
      this.hasNextSong = (params.hasNext as boolean) || false;
      this.hasPreviousSong = (params.hasPrevious as boolean) || false;
      
      // æ›´æ–°å¾ªç¯æ¨¡å¼ (å¦‚æœæä¾›äº†)
      if (params.loopMode !== undefined && params.loopMode !== null) {
        this.currentLoopMode = params.loopMode as number;
      }
      
      // æ’­æ”¾åˆ—è¡¨çŠ¶æ€å˜åŒ–æ—¶ï¼Œåªæ›´æ–°å¾ªç¯æ¨¡å¼ï¼Œä¸é‡å¤è®¾ç½®æ’­æ”¾çŠ¶æ€
      if (this.session && this.isSessionActive && 
          (oldHasNext !== this.hasNextSong || oldHasPrevious !== this.hasPreviousSong || oldLoopMode !== this.currentLoopMode)) {
        
        // åªæ›´æ–°å¾ªç¯æ¨¡å¼ï¼Œä¿æŒå½“å‰æ’­æ”¾çŠ¶æ€å’Œä½ç½®
        await this.updateLoopModeOnly();
        
        hilog.info(DOMAIN, TAG, `Playlist state changed: hasNext=${this.hasNextSong}, hasPrevious=${this.hasPreviousSong}, loopMode=${this.currentLoopMode}`);
      }
      
      hilog.info(DOMAIN, TAG, `Playlist state updated: index=${this.currentPlaylistIndex}, length=${this.playlistLength}, hasNext=${this.hasNextSong}, hasPrevious=${this.hasPreviousSong}`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update playlist state: ${JSON.stringify(error)}`);
    }
  }

  // ä»…æ›´æ–°å¾ªç¯æ¨¡å¼ï¼Œä¸å½±å“æ’­æ”¾çŠ¶æ€å’Œä½ç½®
  private async updateLoopModeOnly(): Promise<void> {
    if (!this.session) return;
    
    try {
      // ä¼˜å…ˆä½¿ç”¨å½“å‰ä¿å­˜çš„å¾ªç¯æ¨¡å¼
      let loopMode = this.currentLoopMode;
      
      // å¦‚æœæ²¡æœ‰è®¾ç½®è¿‡å¾ªç¯æ¨¡å¼ï¼Œåˆ™æ ¹æ®æ’­æ”¾åˆ—è¡¨çŠ¶æ€æ¨æ–­
      if (loopMode === undefined) {
        loopMode = avSession.LoopMode.LOOP_MODE_SEQUENCE;
        if (this.playlistLength <= 1) {
          loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
        } else if (!this.hasNextSong && !this.hasPreviousSong) {
          loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
        }
      }

      // è·å–å½“å‰æ’­æ”¾çŠ¶æ€ï¼Œåªæ›´æ–°å¾ªç¯æ¨¡å¼
      const playbackState: avSession.AVPlaybackState = {
        state: this.isPlaying ? avSession.PlaybackState.PLAYBACK_STATE_PLAY : avSession.PlaybackState.PLAYBACK_STATE_PAUSE,
        loopMode: loopMode,
        isFavorite: false,
        position: {
          elapsedTime: Math.floor(this.currentPosition * 1000), // ä¿æŒå½“å‰ä½ç½®
          updateTime: Date.now()
        }
      };
      
      await this.session.setAVPlaybackState(playbackState);
      hilog.info(DOMAIN, TAG, `Loop mode updated: ${loopMode}, position preserved: ${this.currentPosition.toFixed(1)}s`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update loop mode: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ å¾ªç¯æ¨¡å¼æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // ä»…æ›´æ–°æ­Œè¯ï¼Œä¿æŒå…¶ä»–å…ƒæ•°æ®ä¸å˜
  private async updateLyricsOnly(lyrics: string): Promise<void> {
    if (!this.session) return;
    
    try {
      // æ„å»ºå®Œæ•´çš„AVMetadataå¯¹è±¡ï¼Œä¿æŒç°æœ‰çš„æ­Œæ›²ä¿¡æ¯ï¼Œåªæ›´æ–°æ­Œè¯
      const metadata: avSession.AVMetadata = {
        assetId: 'voicehub_web_player',
        title: this.currentTitle, // ä½¿ç”¨ä¿å­˜çš„æ ‡é¢˜
        artist: this.currentArtist, // ä½¿ç”¨ä¿å­˜çš„è‰ºæœ¯å®¶
        album: this.currentAlbum, // ä½¿ç”¨ä¿å­˜çš„ä¸“è¾‘
        writer: this.currentArtist, // ä½¿ç”¨ä¿å­˜çš„è‰ºæœ¯å®¶ä½œä¸ºä½œè¯è€…
        composer: this.currentArtist, // ä½¿ç”¨ä¿å­˜çš„è‰ºæœ¯å®¶ä½œä¸ºä½œæ›²è€…
        duration: this.currentDuration, // ä¿æŒç°æœ‰çš„æ—¶é•¿ä¿¡æ¯
        description: `${this.currentTitle} - ${this.currentArtist}`, // ä½¿ç”¨ä¿å­˜çš„ä¿¡æ¯æ„å»ºæè¿°
        lyric: lyrics, // æ›´æ–°æ­Œè¯
        previousAssetId: '',
        nextAssetId: ''
      };
      
      // å¦‚æœæœ‰å°é¢å›¾ç‰‡ï¼Œä¹Ÿè¦ä¿æŒ
      if (this.currentCover && this.currentCover.trim() !== '') {
        try {
          const pixelMap = await this.loadCoverImage(this.currentCover);
          if (pixelMap) {
            metadata.mediaImage = pixelMap;
          }
        } catch (error) {
          hilog.warn(DOMAIN, TAG, `Failed to reload cover image for lyrics update: ${JSON.stringify(error)}`);
        }
      }
      
      await this.session.setAVMetadata(metadata);
      hilog.info(DOMAIN, TAG, `Lyrics only updated: ${lyrics.length} characters, title: ${this.currentTitle}, artist: ${this.currentArtist}`);
      this.addDebugMessage(`ğŸ¤ æ­Œè¯æ›´æ–°æˆåŠŸ: ${lyrics.length} å­—ç¬¦ï¼Œä¿æŒæ­Œæ›²ä¿¡æ¯: ${this.currentTitle} - ${this.currentArtist}`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update lyrics only: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ ä»…æ­Œè¯æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // æ›´æ–°æ’­æ”¾çŠ¶æ€
  private async updatePlayState(isPlaying: boolean, position?: number, duration?: number, loopMode?: number): Promise<void> {
    try {
      const oldIsPlaying = this.isPlaying;
      this.isPlaying = isPlaying;
      
      // æ›´æ–°å¾ªç¯æ¨¡å¼ (å¦‚æœæä¾›äº†)
      if (loopMode !== undefined) {
        this.currentLoopMode = loopMode;
      }
      
      // æ€»æ˜¯æ›´æ–°ä½ç½®ï¼Œå¦‚æœæœªæä¾›åˆ™ä½¿ç”¨å½“å‰ä½ç½®
      this.currentPosition = (position !== undefined && position >= 0) ? position : this.currentPosition;
      
      // åªåœ¨æ’­æ”¾çŠ¶æ€å˜åŒ–æ—¶è¾“å‡ºè¯¦ç»†æ—¥å¿—
      // if (oldIsPlaying !== isPlaying) {
      //   this.addDebugMessage(`ğŸ”„ æ’­æ”¾çŠ¶æ€å˜åŒ–: ${oldIsPlaying ? 'æ’­æ”¾' : 'æš‚åœ'} â†’ ${isPlaying ? 'æ’­æ”¾' : 'æš‚åœ'} (ä½ç½®: ${this.currentPosition.toFixed(1)}s)`);
      // }
      
      if (this.session) {
        // å¦‚æœå¼€å§‹æ’­æ”¾ï¼Œæ¿€æ´»AVSession
        if (isPlaying && !this.isSessionActive) {
          await this.activateAVSession();
        }
        
        // åªæ›´æ–°æ’­æ”¾çŠ¶æ€å’Œä½ç½®ï¼Œä¸å½±å“å·²è®¾ç½®çš„å…ƒæ•°æ®
        await this.setPlayStateWithPosition(isPlaying, this.currentPosition);
        
        // æš‚åœåç«‹å³æ›´æ–°ä½ç½®
        if (!isPlaying) {
          setTimeout(() => {
            this.updatePositionOnly(this.currentPosition);
          }, 100);
        }
        
        // åªåœ¨çŠ¶æ€å˜åŒ–æ—¶è¾“å‡ºæˆåŠŸæ—¥å¿—
        // if (oldIsPlaying !== isPlaying) {
        //   this.addDebugMessage(`âœ… æ’­æ”¾çŠ¶æ€æ›´æ–°æˆåŠŸ: ${this.isPlaying ? 'æ’­æ”¾' : 'æš‚åœ'}, ä½ç½®: ${this.currentPosition.toFixed(1)}s`);
        // }
        
      } else {
        hilog.warn(DOMAIN, TAG, 'No AVSession available for playback state update');
        // this.addDebugMessage('âš ï¸ AVSessionä¸å¯ç”¨ï¼Œæ— æ³•æ›´æ–°æ’­æ”¾çŠ¶æ€');
      }
      
      // hilog.info(DOMAIN, TAG, `Play state updated: ${this.isPlaying}, position: ${this.currentPosition}s, duration: ${duration}s`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update play state: ${JSON.stringify(error)}`);
      // this.addDebugMessage(`âŒ æ’­æ”¾çŠ¶æ€æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // è®¾ç½®æ’­æ”¾çŠ¶æ€å’Œä½ç½®
  private async setPlayStateWithPosition(isPlaying: boolean, positionInSeconds: number): Promise<void> {
    if (!this.session) return;
    
    try {
      // ä¼˜å…ˆä½¿ç”¨å½“å‰ä¿å­˜çš„å¾ªç¯æ¨¡å¼
      let loopMode = this.currentLoopMode;
      
      // å¦‚æœæ²¡æœ‰è®¾ç½®è¿‡å¾ªç¯æ¨¡å¼ï¼Œåˆ™æ ¹æ®æ’­æ”¾åˆ—è¡¨çŠ¶æ€æ¨æ–­
      if (loopMode === undefined) {
        loopMode = avSession.LoopMode.LOOP_MODE_SEQUENCE;
        if (this.playlistLength <= 1) {
          loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
        } else if (!this.hasNextSong && !this.hasPreviousSong) {
          loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
        }
      }

      const playbackState: avSession.AVPlaybackState = {
        state: isPlaying ? avSession.PlaybackState.PLAYBACK_STATE_PLAY : avSession.PlaybackState.PLAYBACK_STATE_PAUSE,
        loopMode: loopMode,
        isFavorite: false,
        position: {
          elapsedTime: Math.floor(positionInSeconds * 1000), // è½¬æ¢ä¸ºæ¯«ç§’
          updateTime: Date.now()
        }
      };
      
      await this.session.setAVPlaybackState(playbackState);
      hilog.info(DOMAIN, TAG, `Play state set: ${isPlaying ? 'PLAY' : 'PAUSE'} at ${positionInSeconds.toFixed(1)}s with loop mode: ${loopMode}`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to set play state with position: ${JSON.stringify(error)}`);
      // ArkTSè¦æ±‚æŠ›å‡ºErrorç±»å‹ï¼Œå°†errorè½¬æ¢ä¸ºErrorå®ä¾‹
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error(`Failed to set play state with position: ${JSON.stringify(error)}`);
      }
    }
  }

  // æ›´æ–°åª’ä½“å…ƒæ•°æ®
  private async updateMetadata(params: Record<string, ESObject>): Promise<void> {
    if (!this.session) {
      hilog.warn(DOMAIN, TAG, 'No AVSession available for metadata update');
      return;
    }

    try {
      // ç›´æ¥ä»å‚æ•°è·å–å…ƒæ•°æ®ä¿¡æ¯
      const title = (params.title as string) || '';
      const artist = (params.artist as string) || '';
      const album = (params.album as string) || '';
      const cover = (params.artwork as string) || (params.cover as string) || '';
      
      // ä¿å­˜å½“å‰æ­Œæ›²ä¿¡æ¯åˆ°å®ä¾‹å˜é‡
      this.currentTitle = title;
      this.currentArtist = artist;
      this.currentAlbum = album;
      this.currentCover = cover;
      
      // æ›´æ–°æ—¶é•¿ä¿¡æ¯ï¼ˆå¦‚æœæä¾›ï¼‰
      if (params.duration && typeof params.duration === 'number' && params.duration > 0) {
        this.currentDuration = Math.floor(params.duration * 1000); // è½¬æ¢ä¸ºæ¯«ç§’
      }

      hilog.info(DOMAIN, TAG, `Updating metadata: ${title} by ${artist}, cover: ${cover}`);
      this.addDebugMessage(`ğŸµ æ›´æ–°æ­Œæ›²å…ƒæ•°æ®: ${title} - ${artist}`);

      // ç¡®ä¿AVSessionå·²æ¿€æ´»
      if (!this.isSessionActive) {
        hilog.info(DOMAIN, TAG, 'AVSession not active, activating...');
        await this.activateAVSession();
      }

      // è®°å½•æ’­æ”¾åˆ—è¡¨çŠ¶æ€ - æ§åˆ¶èƒ½åŠ›ç”±ç›‘å¬å™¨è‡ªåŠ¨ç¡®å®š
      this.addDebugMessage(`ğŸ›ï¸ å…ƒæ•°æ®æ›´æ–°æ—¶æ’­æ”¾åˆ—è¡¨çŠ¶æ€: ä¸‹ä¸€é¦–=${this.hasNextSong}, ä¸Šä¸€é¦–=${this.hasPreviousSong}`);
      hilog.info(DOMAIN, TAG, `Metadata update with playlist state: hasNext=${this.hasNextSong}, hasPrevious=${this.hasPreviousSong}`);

      // æ„å»ºå®Œæ•´çš„AVMetadataå¯¹è±¡ï¼Œåªä½¿ç”¨å‰ç«¯ä¼ é€’çš„å®é™…æ•°æ®
      const finalTitle = title;
      const finalArtist = artist;
      const finalAlbum = (params.album as string) || '';
      
      // å¤„ç†æ­Œè¯
      const lyricsParam = params.lyrics as string;
      const finalLyrics = lyricsParam && typeof lyricsParam === 'string' ? lyricsParam : '';
      
      // è¯¦ç»†è®°å½•æ­Œè¯å¤„ç†è¿‡ç¨‹
      hilog.info(DOMAIN, TAG, `Lyrics processing: received param type=${typeof lyricsParam}, value=${lyricsParam ? lyricsParam.substring(0, 100) + '...' : 'null/undefined'}`);
      this.addDebugMessage(`ğŸ¤ æ­Œè¯å¤„ç†: æ¥æ”¶ç±»å‹=${typeof lyricsParam}, é•¿åº¦=${lyricsParam ? lyricsParam.length : 0}`);
      
      if (finalLyrics) {
        // æ£€æŸ¥æ­Œè¯å†…å®¹æ˜¯å¦åŒ…å«è‰ºæœ¯å®¶ä¿¡æ¯ï¼ˆå¯èƒ½çš„é”™è¯¯æ¥æºï¼‰
        const containsArtist = finalLyrics.includes(finalArtist);
        hilog.info(DOMAIN, TAG, `Final lyrics: length=${finalLyrics.length}, contains artist name=${containsArtist}`);
        this.addDebugMessage(`ğŸ¤ æœ€ç»ˆæ­Œè¯: é•¿åº¦=${finalLyrics.length}, åŒ…å«è‰ºæœ¯å®¶å=${containsArtist}`);
        
        // æ˜¾ç¤ºæ­Œè¯å‰å‡ è¡Œç”¨äºè°ƒè¯•
        const firstLines = finalLyrics.split('\r\n').slice(0, 3).join(' | ');
        hilog.info(DOMAIN, TAG, `Lyrics preview: ${firstLines}`);
        this.addDebugMessage(`ğŸ¤ æ­Œè¯é¢„è§ˆ: ${firstLines}`);
      }
      
      let metadata: avSession.AVMetadata = {
        assetId: 'voicehub_web_player',
        title: finalTitle,
        artist: finalArtist,
        album: finalAlbum,
        writer: finalArtist, // æ·»åŠ ä½œè¯è€…å­—æ®µ
        composer: finalArtist, // æ·»åŠ ä½œæ›²è€…å­—æ®µ
        duration: Math.floor(((params.duration as number) || 0) * 1000), // æ·»åŠ æ—¶é•¿å­—æ®µï¼ˆè½¬æ¢ä¸ºæ¯«ç§’ï¼‰
        description: `${finalTitle} - ${finalArtist}`, // æ·»åŠ æè¿°
        lyric: finalLyrics, // æ­Œè¯å­—æ®µ
        previousAssetId: '', // ä¸Šä¸€é¦–æ­Œæ›²ID
        nextAssetId: '' // ä¸‹ä¸€é¦–æ­Œæ›²ID
      };
      
      // è®°å½•å®Œæ•´çš„å…ƒæ•°æ®ä¿¡æ¯ç”¨äºè°ƒè¯•
      hilog.info(DOMAIN, TAG, `Complete metadata: title="${metadata.title}", artist="${metadata.artist}", lyric_length=${metadata.lyric ? metadata.lyric.length : 0}`);
      this.addDebugMessage(`ğŸ“‹ å®Œæ•´å…ƒæ•°æ®: æ ‡é¢˜="${metadata.title}", è‰ºæœ¯å®¶="${metadata.artist}", æ­Œè¯é•¿åº¦=${metadata.lyric ? metadata.lyric.length : 0}`);
      
      // è®°å½•æ­Œè¯ä¿¡æ¯
      if (finalLyrics) {
        hilog.info(DOMAIN, TAG, `Lyrics provided: ${finalLyrics.length} characters`);
        this.addDebugMessage(`ğŸ¤ æ­Œè¯å·²è®¾ç½®: ${finalLyrics.length} å­—ç¬¦`);
      } else {
        hilog.info(DOMAIN, TAG, 'No lyrics provided');
        this.addDebugMessage('ğŸ¤ æ— æ­Œè¯ä¿¡æ¯');
      }

      // å¦‚æœæœ‰å°é¢å›¾ç‰‡ï¼Œå¤„ç†å°é¢
      if (cover && cover.trim() !== '') {
        hilog.info(DOMAIN, TAG, `Loading cover image: ${cover}`);
        this.addDebugMessage(`ğŸ–¼ï¸ åŠ è½½å°é¢å›¾ç‰‡: ${cover.substring(0, 50)}...`);
        try {
          const pixelMap = await this.loadCoverImage(cover);
          if (pixelMap) {
            metadata.mediaImage = pixelMap;
            hilog.info(DOMAIN, TAG, 'Cover image added to metadata successfully');
            this.addDebugMessage('âœ… å°é¢å›¾ç‰‡åŠ è½½æˆåŠŸ');
          } else {
            hilog.warn(DOMAIN, TAG, 'Failed to load cover image - pixelMap is null');
            this.addDebugMessage('âš ï¸ å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥');
          }
        } catch (error) {
          hilog.warn(DOMAIN, TAG, `Failed to load cover image: ${JSON.stringify(error)}`);
          this.addDebugMessage(`âŒ å°é¢å›¾ç‰‡åŠ è½½å¼‚å¸¸: ${JSON.stringify(error)}`);
        }
      } else {
        hilog.info(DOMAIN, TAG, 'No cover image provided');
        this.addDebugMessage('â„¹ï¸ æ— å°é¢å›¾ç‰‡');
      }

      hilog.info(DOMAIN, TAG, `Setting complete metadata: ${JSON.stringify({
        assetId: metadata.assetId,
        title: metadata.title,
        artist: metadata.artist,
        album: metadata.album,
        duration: metadata.duration,
        description: metadata.description,
        hasImage: !!metadata.mediaImage
      })}`);

      await this.session.setAVMetadata(metadata);
      
      // å…ƒæ•°æ®æ›´æ–°åï¼Œç«‹å³æ›´æ–°æ’­æ”¾çŠ¶æ€å’Œä½ç½®
      setTimeout(async () => {
        await this.updatePlayState(this.isPlaying, this.currentPosition, params.duration as number);
      }, 100);
      
      hilog.info(DOMAIN, TAG, `Metadata updated successfully: ${title} by ${artist}`);
      this.addDebugMessage(`âœ… å…ƒæ•°æ®æ›´æ–°æˆåŠŸ: ${title} - ${artist}`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update metadata: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ å…ƒæ•°æ®æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // åŠ è½½å°é¢å›¾ç‰‡
  private async loadCoverImage(coverUrl: string): Promise<image.PixelMap | null> {
    try {
      this.addDebugMessage(`ğŸŒ å¼€å§‹åŠ è½½å°é¢å›¾ç‰‡: ${coverUrl}`);
      
      if (coverUrl.startsWith('http://') || coverUrl.startsWith('https://')) {
        // ç½‘ç»œå›¾ç‰‡
        const httpRequest = http.createHttp();
        
        try {
          this.addDebugMessage('ğŸ“¡ åˆ›å»ºHTTPè¯·æ±‚...');
          // ä½¿ç”¨ç®€åŒ–çš„è¯·æ±‚é…ç½®ï¼Œå‚è€ƒåä¸ºå®˜æ–¹æ¡ˆä¾‹
          const response = await httpRequest.request(coverUrl, {
            method: http.RequestMethod.GET,
            expectDataType: http.HttpDataType.ARRAY_BUFFER,
            connectTimeout: 15000, // 15ç§’è¿æ¥è¶…æ—¶
            readTimeout: 30000,    // 30ç§’è¯»å–è¶…æ—¶
            header: {
              'User-Agent': 'Mozilla/5.0 (Linux; HarmonyOS) VoiceHub/1.0.0',
              'Accept': 'image/*,*/*;q=0.8'
            }
          });
          
          this.addDebugMessage(`ğŸ“Š HTTPå“åº”: çŠ¶æ€ç =${response.responseCode}, æ•°æ®å¤§å°=${response.result instanceof ArrayBuffer ? response.result.byteLength : 'unknown'}`);
          
          if (response.responseCode === 200 && response.result instanceof ArrayBuffer && response.result.byteLength > 0) {
            try {
              this.addDebugMessage(`ğŸ–¼ï¸ åˆ›å»ºImageSourceï¼Œæ•°æ®å¤§å°: ${response.result.byteLength} bytes`);
              
              // ç›´æ¥ä½¿ç”¨ArrayBufferåˆ›å»ºImageSourceï¼Œå‚è€ƒåä¸ºå®˜æ–¹æ¡ˆä¾‹
              const imageSource = image.createImageSource(response.result);
              
              // ä½¿ç”¨åä¸ºå®˜æ–¹æ¡ˆä¾‹æ¨èçš„DecodingOptionsé…ç½®
                const decodingOptions: image.DecodingOptions = {
                  // æ˜¯å¦å¯ç¼–è¾‘
                  editable: false,
                  // åƒç´ æ ¼å¼ï¼šRGBA_8888
                  desiredPixelFormat: image.PixelMapFormat.RGBA_8888,
                  // åˆ›å»ºå›¾ç‰‡å¤§å° - è®¾ç½®ä¸ºåˆç†çš„å°é¢å°ºå¯¸
                  desiredSize: { height: 300, width: 300 }
                };
              
              this.addDebugMessage('ğŸ”„ ä½¿ç”¨åä¸ºå®˜æ–¹æ¨èé…ç½®åˆ›å»ºPixelMap...');
              
              // ä½¿ç”¨å®˜æ–¹æ¡ˆä¾‹çš„æ–¹å¼åˆ›å»ºPixelMap
              const pixelMap = await imageSource.createPixelMap(decodingOptions);
              
              if (pixelMap) {
                this.addDebugMessage('âœ… å°é¢å›¾ç‰‡åŠ è½½æˆåŠŸï¼');
                httpRequest.destroy();
                return pixelMap;
              } else {
                this.addDebugMessage('âŒ PixelMapåˆ›å»ºè¿”å›null');
                
                // å¤‡ç”¨ç­–ç•¥ï¼šå°è¯•ä¸æŒ‡å®šsize
                 try {
                    this.addDebugMessage('ğŸ”„ å¤‡ç”¨ç­–ç•¥ï¼šå°è¯•ä¸æŒ‡å®šå°ºå¯¸...');
                    const backupOptions: image.DecodingOptions = {
                      editable: false,
                      desiredPixelFormat: image.PixelMapFormat.RGBA_8888
                    };
                  const backupPixelMap = await imageSource.createPixelMap(backupOptions);
                  if (backupPixelMap) {
                    this.addDebugMessage('âœ… å¤‡ç”¨ç­–ç•¥æˆåŠŸï¼');
                    httpRequest.destroy();
                    return backupPixelMap;
                  }
                } catch (backupError) {
                  this.addDebugMessage(`âŒ å¤‡ç”¨ç­–ç•¥å¤±è´¥: ${JSON.stringify(backupError)}`);
                }
                
                httpRequest.destroy();
                return null;
              }
            } catch (imageError) {
              this.addDebugMessage(`âŒ ImageSourceå¤„ç†å¤±è´¥: ${JSON.stringify(imageError)}`);
              httpRequest.destroy();
              
              // å¦‚æœä¸»è¦æ–¹æ³•å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨æ–¹æ³•
              this.addDebugMessage('ğŸ”„ å°è¯•å¤‡ç”¨åŠ è½½æ–¹æ³•...');
              return await this.loadCoverImageAlternative(coverUrl);
            }
          } else {
            this.addDebugMessage(`âš ï¸ æ— æ•ˆå“åº”: çŠ¶æ€ç =${response.responseCode}, æœ‰æ•°æ®=${response.result instanceof ArrayBuffer}, å¤§å°=${response.result instanceof ArrayBuffer ? response.result.byteLength : 'N/A'}`);
            httpRequest.destroy();
            
            // å°è¯•å¤‡ç”¨æ–¹æ¡ˆ
            if (response.responseCode === 403 || response.responseCode === 404) {
              this.addDebugMessage('ğŸ”„ å°è¯•å¤‡ç”¨è¯·æ±‚æ–¹æ³•...');
              return await this.loadCoverImageAlternative(coverUrl);
            }
            
            return null;
          }
        } catch (httpError) {
          this.addDebugMessage(`âŒ HTTPè¯·æ±‚å¤±è´¥: ${JSON.stringify(httpError)}`);
          httpRequest.destroy();
          return null;
        }
      } else if (coverUrl.startsWith('/')) {
        // æœ¬åœ°èµ„æº
        try {
          this.addDebugMessage(`ğŸ“ åŠ è½½æœ¬åœ°å›¾ç‰‡: ${coverUrl}`);
          const imageSource = image.createImageSource(coverUrl);
          
          // å¯¹æœ¬åœ°å›¾ç‰‡ä¹Ÿä½¿ç”¨ç›¸åŒçš„é…ç½®
            const localOptions: image.DecodingOptions = {
              editable: false,
              desiredPixelFormat: image.PixelMapFormat.RGBA_8888,
              desiredSize: { height: 300, width: 300 }
            };
          
          const pixelMap = await imageSource.createPixelMap(localOptions);
          
          if (pixelMap) {
            this.addDebugMessage('âœ… æœ¬åœ°å°é¢å›¾ç‰‡åŠ è½½æˆåŠŸ');
            return pixelMap;
          } else {
            this.addDebugMessage('âŒ æœ¬åœ°PixelMapåˆ›å»ºè¿”å›null');
            return null;
          }
        } catch (localError) {
          this.addDebugMessage(`âŒ æœ¬åœ°å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥: ${JSON.stringify(localError)}`);
          return null;
        }
      }
      
      this.addDebugMessage(`âš ï¸ ä¸æ”¯æŒçš„å°é¢URLæ ¼å¼: ${coverUrl}`);
      return null;
    } catch (error) {
      this.addDebugMessage(`âŒ å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥: ${JSON.stringify(error)}`);
      return null;
    }
  }



  // å¤‡ç”¨å°é¢å›¾ç‰‡åŠ è½½æ–¹æ³• - ä½¿ç”¨åä¸ºå®˜æ–¹æ¨èé…ç½®
  private async loadCoverImageAlternative(coverUrl: string): Promise<image.PixelMap | null> {
    try {
      this.addDebugMessage(`ğŸ”„ ä½¿ç”¨å¤‡ç”¨æ–¹æ³•åŠ è½½å°é¢å›¾ç‰‡: ${coverUrl}`);
      
      const httpRequest = http.createHttp();
      
      try {
        this.addDebugMessage('ğŸ“¡ åˆ›å»ºå¤‡ç”¨HTTPè¯·æ±‚ï¼ˆç®€åŒ–é…ç½®ï¼‰...');
        // ä½¿ç”¨ç®€åŒ–çš„è¯·æ±‚é…ç½®
        const response = await httpRequest.request(coverUrl, {
          method: http.RequestMethod.GET,
          expectDataType: http.HttpDataType.ARRAY_BUFFER,
          connectTimeout: 10000,
          readTimeout: 15000,
          header: {
            'User-Agent': 'VoiceHub/1.0.0',
            'Accept': 'image/*,*/*;q=0.8'
          }
        });
        
        this.addDebugMessage(`ğŸ“Š å¤‡ç”¨è¯·æ±‚å“åº”: çŠ¶æ€ç =${response.responseCode}`);
        
        if (response.responseCode === 200 && response.result instanceof ArrayBuffer && response.result.byteLength > 0) {
          try {
            this.addDebugMessage(`ğŸ–¼ï¸ å¤‡ç”¨æ–¹æ³•åˆ›å»ºImageSourceï¼Œæ•°æ®å¤§å°: ${response.result.byteLength} bytes`);
            const imageSource = image.createImageSource(response.result);
            
            // ä½¿ç”¨ä¸ä¸»æ–¹æ³•ç›¸åŒçš„åä¸ºå®˜æ–¹æ¨èé…ç½®
             const decodingOptions: image.DecodingOptions = {
               editable: false,
               desiredPixelFormat: image.PixelMapFormat.RGBA_8888,
               desiredSize: { height: 200, width: 200 } // å¤‡ç”¨æ–¹æ³•ä½¿ç”¨ç¨å°çš„å°ºå¯¸
             };
            
            this.addDebugMessage('ğŸ”„ å¤‡ç”¨æ–¹æ³•ä½¿ç”¨å®˜æ–¹é…ç½®åˆ›å»ºPixelMap...');
            const pixelMap = await imageSource.createPixelMap(decodingOptions);
            
            if (pixelMap) {
              this.addDebugMessage('âœ… å¤‡ç”¨æ–¹æ³•å°é¢å›¾ç‰‡åŠ è½½æˆåŠŸ');
              httpRequest.destroy();
              return pixelMap;
            } else {
              this.addDebugMessage('âŒ å¤‡ç”¨æ–¹æ³•PixelMapåˆ›å»ºè¿”å›null');
              
              // æœ€åå°è¯•ï¼šä¸æŒ‡å®šå°ºå¯¸
               try {
                  this.addDebugMessage('ğŸ”„ å¤‡ç”¨æ–¹æ³•æœ€åå°è¯•ï¼šä¸æŒ‡å®šå°ºå¯¸...');
                  const finalOptions: image.DecodingOptions = {
                    editable: false,
                    desiredPixelFormat: image.PixelMapFormat.RGBA_8888
                  };
                const finalPixelMap = await imageSource.createPixelMap(finalOptions);
                if (finalPixelMap) {
                  this.addDebugMessage('âœ… å¤‡ç”¨æ–¹æ³•æœ€åå°è¯•æˆåŠŸï¼');
                  httpRequest.destroy();
                  return finalPixelMap;
                }
              } catch (finalError) {
                this.addDebugMessage(`âŒ å¤‡ç”¨æ–¹æ³•æœ€åå°è¯•å¤±è´¥: ${JSON.stringify(finalError)}`);
              }
              
              httpRequest.destroy();
              return null;
            }
          } catch (imageError) {
            this.addDebugMessage(`âŒ å¤‡ç”¨æ–¹æ³•å›¾ç‰‡å¤„ç†å¤±è´¥: ${JSON.stringify(imageError)}`);
            httpRequest.destroy();
            return null;
          }
        } else {
          this.addDebugMessage(`âŒ å¤‡ç”¨æ–¹æ³•æ— æ•ˆå“åº”: çŠ¶æ€ç =${response.responseCode}`);
          httpRequest.destroy();
          return null;
        }
      } catch (httpError) {
        this.addDebugMessage(`âŒ å¤‡ç”¨HTTPè¯·æ±‚å¤±è´¥: ${JSON.stringify(httpError)}`);
        httpRequest.destroy();
        return null;
      }
    } catch (error) {
      this.addDebugMessage(`âŒ å¤‡ç”¨å°é¢åŠ è½½å¤±è´¥: ${JSON.stringify(error)}`);
      return null;
    }
  }

  build() {
    Stack() {
      // ä¸»å†…å®¹åŒºåŸŸ - WebViewå æ»¡å…¨å±
      Column() {
        // åŠ è½½è¿›åº¦æ¡
        WebLoadingProgress({ 
          isLoading: this.isLoading, 
          loadProgress: this.loadProgress 
        })

        // WebViewæ˜¾ç¤ºå®Œæ•´ç½‘ç«™
        Web({ src: this.currentUrl, controller: this.webController })
          .layoutWeight(1)
          .width('100%')
          .javaScriptAccess(true)
          .domStorageAccess(true)
          .fileAccess(true)
          .imageAccess(true)
          .onlineImageAccess(true)
          .databaseAccess(true)
          .geolocationAccess(false)
          .mixedMode(MixedMode.All)
          .cacheMode(CacheMode.Default)
          .userAgent('VoiceHub-HarmonyOS/1.0.0 (HarmonyOS; Mobile) Mozilla/5.0 (Linux; Android 10; HarmonyOS) AppleWebKit/537.36')
          .onControllerAttached(() => {
            this.controllerAttached = true;
            this.addDebugMessage('ğŸ”— WebviewController å·²æˆåŠŸç»‘å®šåˆ° Web ç»„ä»¶');
          })
          .onProgressChange((event) => {
            this.loadProgress = event?.newProgress || 0;
            this.addDebugMessage(`ğŸ“Š é¡µé¢åŠ è½½è¿›åº¦: ${this.loadProgress}%`);
          })
          .onPageBegin((event) => {
            const url = event?.url || 'unknown';
            this.addDebugMessage(`ğŸŒ å¼€å§‹åŠ è½½é¡µé¢: ${url}`);
            this.isLoading = true;
            this.checkAndSetImmersiveMode(url);
          })
          .onPageEnd(() => {
            this.onPageEnd();
          })
          .onErrorReceive((event) => {
            const errorInfo = event?.error?.getErrorInfo();
            const errorCode = event?.error?.getErrorCode();
            hilog.error(DOMAIN, TAG, `WebView error: ${errorInfo}, code: ${errorCode}`);
            this.addDebugMessage(`âŒ WebView é”™è¯¯: ${errorInfo} (ä»£ç : ${errorCode})`);
          })
          .onHttpErrorReceive((event) => {
            const statusCode = event?.response?.getResponseCode();
            const url = event?.request?.getRequestUrl();
            hilog.error(DOMAIN, TAG, `HTTP error: ${statusCode} for ${url}`);
            this.addDebugMessage(`âŒ HTTP é”™è¯¯: ${statusCode} - ${url}`);
          })
          .onSslErrorReceive((event) => {
            hilog.error(DOMAIN, TAG, `SSL error: ${JSON.stringify(event)}`);
            this.addDebugMessage(`âŒ SSL é”™è¯¯: ${JSON.stringify(event)}`);
          })
          .javaScriptProxy({
            object: {
              onMessage: (message: string): void => {
                this.onMessage(message);
              }
            },
            name: 'harmonyos',
            methodList: ['onMessage'],
            controller: this.webController
          })
      }
      .width('100%')
      .height('100%')
      .gesture(
        PanGesture({ fingers: 1, direction: PanDirection.Left, distance: 50 })
          .onActionStart(() => {
            // å·¦æ»‘å¼€å§‹
            this.addDebugMessage('ğŸ‘† æ£€æµ‹åˆ°å·¦æ»‘æ‰‹åŠ¿å¼€å§‹');
          })
          .onActionUpdate((event: GestureEvent) => {
            // å·¦æ»‘è¿‡ç¨‹ä¸­ï¼Œå½“æ»‘åŠ¨è·ç¦»è¶…è¿‡50åƒç´ æ—¶è§¦å‘
            if (event.offsetX < -50) {
              // æ£€æŸ¥WebViewæ˜¯å¦å¯ä»¥è¿”å›ä¸Šä¸€é¡µ
              if (this.webController.accessBackward()) {
                this.webController.backward();
                this.addDebugMessage('ğŸ”™ å·¦æ»‘è§¦å‘ï¼šWebViewè¿”å›ä¸Šä¸€é¡µ');
              } else {
                // å¦‚æœWebViewæ— æ³•è¿”å›ï¼Œåˆ™æ‰“å¼€è®¾ç½®é¡µé¢
                this.showUrlSettings = true;
                this.addDebugMessage('ğŸ”™ å·¦æ»‘è§¦å‘ï¼šé¦–é¡µæ‰“å¼€è®¾ç½®é¡µé¢');
              }
            }
          })
          .onActionEnd(() => {
            // å·¦æ»‘ç»“æŸ
            this.addDebugMessage('ğŸ‘† å·¦æ»‘æ‰‹åŠ¿ç»“æŸ');
          })
      )



      // URLè®¾ç½®ç•Œé¢
      WebViewSettings({
        showUrlSettings: $showUrlSettings,
        currentUrl: $currentUrl,
        inputUrl: $inputUrl,
        savedUrls: $savedUrls,
        showDebugInfo: $showDebugInfo,
        controllerAttached: this.controllerAttached,
        webController: this.webController,
        dataPreferences: this.dataPreferences,
        onAddDebugMessage: this.addDebugMessage.bind(this),
        onSaveUrl: this.saveUrl.bind(this),
        onDeleteUrl: this.deleteUrl.bind(this)
      })



      // è°ƒè¯•ä¿¡æ¯ç»„ä»¶
      DebugInfo({
        showDebugInfo: $showDebugInfo,
        debugMessages: this.debugMessages,
        onClearDebugMessages: this.clearDebugMessages.bind(this)
      })
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#000000')
    .expandSafeArea(this.safeAreaTypes, this.safeAreaEdges)
  }
}