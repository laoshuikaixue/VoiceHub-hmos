import { webview } from '@kit.ArkWeb';
import { avSession } from '@kit.AVSessionKit';
import { image } from '@kit.ImageKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { http } from '@kit.NetworkKit';

const TAG = 'VoiceHubIndex';
const DOMAIN = 0x0000;

@Entry
@Component
struct Index {
  @State isLoading: boolean = true;
  @State loadProgress: number = 0;
  @State currentUrl: string = 'https://voicehub.lao-shui.top';
  @State isPlaying: boolean = false;
  @State currentSong: string = '';
  @State currentArtist: string = '';
  @State currentCover: string = '';
  @State showDebugInfo: boolean = false;
  @State debugMessages: string[] = [];
  
  // æ’­æ”¾åˆ—è¡¨çŠ¶æ€
  @State currentPlaylistIndex: number = -1;
  @State playlistLength: number = 0;
  @State hasNextSong: boolean = false;
  @State hasPreviousSong: boolean = false;
  
  // æ’­æ”¾ä½ç½®çŠ¶æ€ï¼ˆå‚è€ƒMelotopiaé¡¹ç›®ï¼‰
  private currentPosition: number = 0;
  private currentDuration: number = 0;
  
  private webController: webview.WebviewController = new webview.WebviewController();
  private session?: avSession.AVSession;
  private isSessionActive: boolean = false;

  aboutToAppear() {
    this.addDebugMessage('ğŸš€ VoiceHub åº”ç”¨å¯åŠ¨');
    // æ£€æŸ¥ç½‘ç»œè¿æ¥
    this.checkNetworkConnection();
    // åœ¨é¢„è§ˆæ¨¡å¼ä¸‹ä¸åˆå§‹åŒ–AVSession
    try {
      this.initAVSession();
    } catch (error) {
      hilog.warn(DOMAIN, TAG, 'Failed to initialize AVSession in preview mode');
      this.addDebugMessage('âš ï¸ é¢„è§ˆæ¨¡å¼ä¸‹è·³è¿‡AVSessionåˆå§‹åŒ–');
    }
  }

  aboutToDisappear() {
    this.releaseAVSession();
  }

  // æ·»åŠ è°ƒè¯•ä¿¡æ¯åˆ°ç•Œé¢æ˜¾ç¤º
  private addDebugMessage(message: string): void {
    const timestamp = new Date().toLocaleTimeString();
    const fullMessage = `[${timestamp}] ${message}`;
    this.debugMessages.push(fullMessage);
    // // ä¿æŒæœ€å¤š20æ¡æ¶ˆæ¯
    // if (this.debugMessages.length > 20) {
    //   this.debugMessages.shift();
    // }
    hilog.info(DOMAIN, TAG, message);
  }

  // æ¸…é™¤è°ƒè¯•ä¿¡æ¯
  private clearDebugMessages(): void {
    this.debugMessages = [];
  }

  // æ£€æŸ¥ç½‘ç»œè¿æ¥
  private async checkNetworkConnection(): Promise<void> {
    try {
      this.addDebugMessage('ğŸ” æ£€æŸ¥ç½‘ç»œè¿æ¥...');
      
      const httpRequest = http.createHttp();
      const testUrl = this.currentUrl;
      
      httpRequest.request(testUrl, {
        method: http.RequestMethod.GET,
        connectTimeout: 5000,
        readTimeout: 5000,
        header: {
          'User-Agent': 'VoiceHub-HarmonyOS/1.0.0'
        }
      }).then((response) => {
        if (response.responseCode === 200) {
          this.addDebugMessage('âœ… ç½‘ç»œè¿æ¥æ­£å¸¸ï¼ŒæœåŠ¡å™¨å¯è®¿é—®');
        } else {
          this.addDebugMessage(`âš ï¸ æœåŠ¡å™¨å“åº”å¼‚å¸¸: ${response.responseCode}`);
        }
        httpRequest.destroy();
      }).catch((error: BusinessError) => {
        this.addDebugMessage(`âŒ ç½‘ç»œè¿æ¥å¤±è´¥: ${JSON.stringify(error)}`);
        this.addDebugMessage('ğŸ’¡ è¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®æˆ–æœåŠ¡å™¨çŠ¶æ€');
        httpRequest.destroy();
      });
    } catch (error) {
      this.addDebugMessage(`âŒ ç½‘ç»œæ£€æŸ¥å¼‚å¸¸: ${JSON.stringify(error)}`);
    }
  }

  // åˆå§‹åŒ–AVSession
  private async initAVSession(): Promise<void> {
    try {
      this.session = await avSession.createAVSession(getContext(this), 'VoiceHub', 'audio');
      hilog.info(DOMAIN, TAG, 'AVSession created successfully');
      
      // æ³¨å†Œæ§åˆ¶å‘½ä»¤ç›‘å¬å™¨
      this.session.on('play', this.handleSystemPlay.bind(this));
      this.session.on('pause', this.handleSystemPause.bind(this));
      this.session.on('stop', this.handleSystemStop.bind(this));
      this.session.on('playNext', this.handleSystemNext.bind(this));
      this.session.on('playPrevious', this.handleSystemPrevious.bind(this));
      this.session.on('seek', this.handleSystemSeek.bind(this));
      
      hilog.info(DOMAIN, TAG, 'AVSession control listeners registered successfully');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to create AVSession: ${JSON.stringify(error)}`);
    }
  }

  // æ¿€æ´»AVSessionï¼ˆä»…åœ¨å¼€å§‹æ’­æ”¾æ—¶è°ƒç”¨ï¼‰
  private async activateAVSession(): Promise<void> {
    if (!this.session || this.isSessionActive) return;
    
    try {
      await this.session.activate();
      this.isSessionActive = true;
      hilog.info(DOMAIN, TAG, 'AVSession activated');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to activate AVSession: ${JSON.stringify(error)}`);
    }
  }

  // åœç”¨AVSessionï¼ˆåœ¨åœæ­¢æ’­æ”¾æ—¶è°ƒç”¨ï¼‰
  private async deactivateAVSession(): Promise<void> {
    if (!this.session || !this.isSessionActive) return;
    
    try {
      await this.session.deactivate();
      this.isSessionActive = false;
      hilog.info(DOMAIN, TAG, 'AVSession deactivated');
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to deactivate AVSession: ${JSON.stringify(error)}`);
    }
  }

  // ç³»ç»Ÿæ§åˆ¶å‘½ä»¤å¤„ç† - é€šè¿‡WebViewä¸ç½‘é¡µæ’­æ”¾å™¨äº¤äº’
  private handleSystemPlay() {
    this.addDebugMessage('â–¶ï¸ ç³»ç»Ÿæ§åˆ¶: æ’­æ”¾');
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨æ’­æ”¾
    this.webController.runJavaScript(`
      if (window.voiceHubPlayer && window.voiceHubPlayer.play) {
        window.voiceHubPlayer.play();
      }
    `);
  }

  private handleSystemPause() {
    this.addDebugMessage('â¸ï¸ ç³»ç»Ÿæ§åˆ¶: æš‚åœ');
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨æš‚åœ
    this.webController.runJavaScript(`
      if (window.voiceHubPlayer && window.voiceHubPlayer.pause) {
        window.voiceHubPlayer.pause();
      }
    `);
  }

  private handleSystemStop() {
    this.addDebugMessage('â¹ï¸ ç³»ç»Ÿæ§åˆ¶: åœæ­¢');
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨åœæ­¢
    this.webController.runJavaScript(`
      if (window.voiceHubPlayer && window.voiceHubPlayer.stop) {
        window.voiceHubPlayer.stop();
      }
    `);
  }

  private handleSystemNext() {
    if (!this.hasNextSong) {
      this.addDebugMessage('â­ï¸ ç³»ç»Ÿæ§åˆ¶: ä¸‹ä¸€é¦– (å·²ç¦ç”¨ - æ²¡æœ‰ä¸‹ä¸€é¦–)');
      return;
    }
    
    this.addDebugMessage('â­ï¸ ç³»ç»Ÿæ§åˆ¶: ä¸‹ä¸€é¦–');
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨ä¸‹ä¸€é¦–
    this.webController.runJavaScript(`
      if (window.voiceHubPlayer && window.voiceHubPlayer.next) {
        window.voiceHubPlayer.next();
      }
    `);
  }

  private handleSystemPrevious() {
    if (!this.hasPreviousSong) {
      this.addDebugMessage('â®ï¸ ç³»ç»Ÿæ§åˆ¶: ä¸Šä¸€é¦– (å·²ç¦ç”¨ - æ²¡æœ‰ä¸Šä¸€é¦–)');
      return;
    }
    
    this.addDebugMessage('â®ï¸ ç³»ç»Ÿæ§åˆ¶: ä¸Šä¸€é¦–');
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨ä¸Šä¸€é¦–
    this.webController.runJavaScript(`
      if (window.voiceHubPlayer && window.voiceHubPlayer.previous) {
        window.voiceHubPlayer.previous();
      }
    `);
  }

  private handleSystemSeek(time: number) {
    // ç³»ç»Ÿä¼ å…¥çš„æ—¶é—´æ˜¯æ¯«ç§’ï¼Œéœ€è¦è½¬æ¢ä¸ºç§’
    const timeInSeconds = time / 1000;
    this.addDebugMessage(`â© ç³»ç»Ÿæ§åˆ¶: è·³è½¬åˆ° ${timeInSeconds.toFixed(1)}s (åŸå§‹: ${time}ms)`);
    
    // é€šçŸ¥ç½‘é¡µæ’­æ”¾å™¨è·³è½¬è¿›åº¦ï¼ˆä¼ é€’ç§’æ•°ï¼‰
    this.webController.runJavaScript(`
      try {
        const targetTime = ${timeInSeconds};
        console.log('VoiceHub: Seeking to', targetTime, 'seconds');
        
        if (window.voiceHubPlayer && window.voiceHubPlayer.seek) {
          window.voiceHubPlayer.seek(targetTime);
        } else if (window.audioPlayerInstance && window.audioPlayerInstance.seekToTime) {
          window.audioPlayerInstance.seekToTime(targetTime);
        } else {
          console.warn('VoiceHub: No seek method available');
        }
      } catch (error) {
        console.error('VoiceHub: Seek error:', error);
      }
    `);
  }

  private releaseAVSession() {
    if (this.session) {
      this.session.deactivate();
      this.session.destroy();
      this.session = undefined;
      this.isSessionActive = false;
    }
  }

  // WebViewé¡µé¢åŠ è½½å®Œæˆ
  private onPageEnd() {
    this.isLoading = false;
    this.addDebugMessage(`ğŸŒ é¡µé¢åŠ è½½å®Œæˆ: ${this.currentUrl}`);
    
    // æ³¨å…¥åŸç”Ÿæ¥å£åˆ°WebViewï¼Œå»ºç«‹åŒå‘é€šä¿¡æ¡¥æ¢
    const jsCode = `
      // åˆ›å»ºHarmonyOSåŸç”Ÿæ¥å£å¯¹è±¡
      window.HarmonyOS = {
        // è°ƒç”¨åŸç”Ÿæ–¹æ³•
        callNative: function(method, parameters) {
          try {
            const message = JSON.stringify({ method: method, parameters: parameters });
            if (window.harmonyos && window.harmonyos.onMessage) {
              window.harmonyos.onMessage(message);
            }
          } catch (error) {
            console.error('Failed to call native method:', error);
          }
        },
        
        // å‘é€æ¶ˆæ¯åˆ°åŸç”Ÿä¾§ï¼ˆä¸callNativeåŠŸèƒ½ç›¸åŒï¼Œæä¾›å…¼å®¹æ€§ï¼‰
        postMessage: function(message) {
          try {
            if (window.harmonyos && window.harmonyos.onMessage) {
              window.harmonyos.onMessage(message);
            }
          } catch (error) {
            console.error('Failed to post message to native:', error);
          }
        }
      };
      
      // ä¸ºç½‘é¡µæ’­æ”¾å™¨æä¾›ç³»ç»Ÿæ§åˆ¶æ¥å£
      window.voiceHubPlayer = {
        // å½“ç½‘é¡µæ’­æ”¾å™¨çŠ¶æ€æ”¹å˜æ—¶è°ƒç”¨
        onPlayStateChanged: function(isPlaying, songInfo) {
          console.log('VoiceHub: Play state changed', isPlaying, songInfo);
          window.HarmonyOS.callNative('updatePlayState', {
            isPlaying: isPlaying,
            title: songInfo.title || '',
            artist: songInfo.artist || '',
            album: songInfo.album || '',
            cover: songInfo.cover || '',
            duration: songInfo.duration || 0,
            position: songInfo.position || 0
          });
        },
        
        // å½“æ­Œæ›²ä¿¡æ¯æ›´æ–°æ—¶è°ƒç”¨
        onSongChanged: function(songInfo) {
          console.log('VoiceHub: Song changed', songInfo);
          window.HarmonyOS.callNative('updateMetadata', {
            title: songInfo.title || '',
            artist: songInfo.artist || '',
            album: songInfo.album || '',
            cover: songInfo.cover || '',
            duration: songInfo.duration || 0,
            lyrics: songInfo.lyrics || '' // ä¿æŒå­—æ®µåä¸€è‡´ï¼šlyrics
          });
        },
        
        // ç³»ç»Ÿæ§åˆ¶æ¥å£ï¼ˆä¾›é¸¿è’™è°ƒç”¨ï¼‰
        play: function() {
          console.log('VoiceHub: System play command received');
          // ä½¿ç”¨windowäº‹ä»¶åˆ†å‘æœºåˆ¶
          window.dispatchEvent(new CustomEvent('harmonyos-play'));
          // å¤‡ç”¨æ–¹æ¡ˆï¼šå°è¯•Nuxtäº‹ä»¶æ€»çº¿
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-play');
          }
        },
        
        pause: function() {
          console.log('VoiceHub: System pause command received');
          window.dispatchEvent(new CustomEvent('harmonyos-pause'));
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-pause');
          }
        },
        
        stop: function() {
          console.log('VoiceHub: System stop command received');
          window.dispatchEvent(new CustomEvent('harmonyos-stop'));
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-stop');
          }
        },
        
        next: function() {
          console.log('VoiceHub: System next command received');
          window.dispatchEvent(new CustomEvent('harmonyos-next'));
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-next');
          }
        },
        
        previous: function() {
          console.log('VoiceHub: System previous command received');
          window.dispatchEvent(new CustomEvent('harmonyos-previous'));
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-previous');
          }
        },
        
        seek: function(time) {
          console.log('VoiceHub: System seek command received, time:', time);
          window.dispatchEvent(new CustomEvent('harmonyos-seek', { detail: { time: time } }));
          if (window.__NUXT__ && window.__NUXT__.$nuxt && window.__NUXT__.$nuxt.$emit) {
            window.__NUXT__.$nuxt.$emit('harmonyos-seek', { time: time });
          }
        },
        
        // æ›´æ–°æ’­æ”¾åˆ—è¡¨çŠ¶æ€
        updatePlaylistState: function(playlistState) {
          console.log('VoiceHub: Playlist state update received:', playlistState);
          // é€šè¿‡WebViewæ¶ˆæ¯æœºåˆ¶å‘é€åˆ°é¸¿è’™ä¾§
          if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.webViewHandler) {
            window.webkit.messageHandlers.webViewHandler.postMessage(JSON.stringify({
              method: 'updatePlaylistState',
              parameters: playlistState
            }));
          }
        },
        
        // æ›´æ–°æ­Œè¯ - æ–°å¢æ¥å£
        updateLyrics: function(lyrics) {
          console.log('VoiceHub: Lyrics update received, length:', lyrics ? lyrics.length : 0);
          // é€šè¿‡WebViewæ¶ˆæ¯æœºåˆ¶å‘é€åˆ°é¸¿è’™ä¾§
          window.HarmonyOS.callNative('updateLyrics', {
            lyrics: lyrics || ''
          });
        }
      };
      
      // ç§»é™¤æ‰€æœ‰DOMéŸ³é¢‘å…ƒç´ ç›‘å¬çš„å¤‡ç”¨æ–¹æ¡ˆ
      // åªä½¿ç”¨ä¸“é—¨çš„å‰ç«¯çŠ¶æ€åŒæ­¥æœºåˆ¶ï¼Œä¸è¿›è¡Œä»»ä½•æœ¬åœ°åˆ¤æ–­æˆ–å¤‡ç”¨æ–¹æ¡ˆ
      
      console.log('VoiceHub HarmonyOS bridge initialized');
    `;
    
    this.webController.runJavaScript(jsCode);
  }

  // å¤„ç†æ¥è‡ªWebViewçš„æ¶ˆæ¯ï¼ˆæ”¹è¿›äº‹ä»¶é©±åŠ¨æœºåˆ¶ï¼‰
  private onMessage(message: string): void {
    try {
      const data: Record<string, ESObject> = JSON.parse(message) as Record<string, ESObject>;
      hilog.info(DOMAIN, TAG, `Received message from WebView: ${JSON.stringify(data)}`);
      
      const method = data.method as string;
      const parameters = data.parameters as Record<string, ESObject>;
      
      switch (method) {
        case 'updatePlayState':
          // æ’­æ”¾çŠ¶æ€æ›´æ–° - ä¼˜å…ˆçº§æœ€é«˜ï¼Œç«‹å³å¤„ç†
          if (parameters && typeof parameters.isPlaying === 'boolean') {
            const position = parameters.position as number;
            const duration = parameters.duration as number;
            
            this.addDebugMessage(`ğŸ“¨ æ”¶åˆ°æ’­æ”¾çŠ¶æ€æ›´æ–°æ¶ˆæ¯: ${parameters.isPlaying ? 'æ’­æ”¾' : 'æš‚åœ'}`);
            
            // åªæ›´æ–°æ’­æ”¾çŠ¶æ€ï¼Œä¸è§¦å‘å…ƒæ•°æ®æ›´æ–°
            this.updatePlayState(parameters.isPlaying as boolean, position, duration);
            
            // æ’­æ”¾çŠ¶æ€æ›´æ–°æ—¶ä¸å¤„ç†å…ƒæ•°æ®ï¼Œé¿å…è¦†ç›–å·²è®¾ç½®çš„æ­Œæ›²ä¿¡æ¯
            // å…ƒæ•°æ®åº”è¯¥é€šè¿‡ä¸“é—¨çš„ updateMetadata æ¶ˆæ¯æ¥æ›´æ–°
          }
          break;
        case 'updateMetadata':
          // æ­Œæ›²åˆ‡æ¢ - éœ€è¦æ›´æ–°å…ƒæ•°æ®å’Œé‡ç½®æ’­æ”¾çŠ¶æ€
          if (parameters) {
            this.updateMetadata(parameters);
          }
          break;
        case 'updatePlaylistState':
          // æ’­æ”¾åˆ—è¡¨æ›´æ–° - åªæ›´æ–°åˆ—è¡¨çŠ¶æ€ï¼Œä¸å½±å“å½“å‰æ’­æ”¾
          if (parameters) {
            this.updatePlaylistState(parameters).catch((error: Error | BusinessError) => {
              hilog.error(DOMAIN, TAG, `Failed to update playlist state: ${JSON.stringify(error)}`);
              this.addDebugMessage(`âŒ æ’­æ”¾åˆ—è¡¨çŠ¶æ€æ›´æ–°å¼‚æ­¥å¤±è´¥: ${JSON.stringify(error)}`);
            });
          }
          break;
        case 'positionUpdate':
          // æ’­æ”¾ä½ç½®æ›´æ–° - æ–°å¢äº‹ä»¶ç±»å‹
          if (parameters && typeof parameters.position === 'number') {
            this.handlePositionUpdate(parameters);
          }
          break;
        case 'updateLyrics':
          // æ­Œè¯æ›´æ–° - æ–°å¢äº‹ä»¶ç±»å‹
          if (parameters) {
            this.handleLyricsUpdate(parameters);
          }
          break;
        default:
          hilog.warn(DOMAIN, TAG, `Unknown method: ${method}`);
          this.addDebugMessage(`âš ï¸ æœªçŸ¥æ–¹æ³•: ${method}`);
      }
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Error parsing WebView message: ${error}`);
      this.addDebugMessage(`âŒ WebViewæ¶ˆæ¯è§£æé”™è¯¯: ${JSON.stringify(error)}`);
    }
  }

  // å¤„ç†æ’­æ”¾ä½ç½®æ›´æ–°ï¼ˆæ–°å¢æ–¹æ³•ï¼‰
  private handlePositionUpdate(params: Record<string, ESObject>): void {
    try {
      const position = params.position as number;
      if (position !== undefined && position >= 0) {
        this.currentPosition = position;
        this.addDebugMessage(`â±ï¸ æ’­æ”¾ä½ç½®æ›´æ–°: ${position.toFixed(1)}s`);
        
        // åªæ›´æ–°ä½ç½®ä¿¡æ¯ï¼Œä¸æ”¹å˜æ’­æ”¾çŠ¶æ€
        if (this.session && this.isSessionActive) {
          this.updatePositionOnly(position);
        }
      }
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to handle position update: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ æ’­æ”¾ä½ç½®æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // å¤„ç†æ­Œè¯æ›´æ–°ï¼ˆæ–°å¢æ–¹æ³•ï¼‰
  private async handleLyricsUpdate(params: Record<string, ESObject>): Promise<void> {
    try {
      const lyrics = params.lyrics as string;
      this.addDebugMessage(`ğŸ¤ æ”¶åˆ°æ­Œè¯æ›´æ–°: é•¿åº¦=${lyrics ? lyrics.length : 0}`);
      
      if (!this.session) {
        this.addDebugMessage('âš ï¸ AVSessionä¸å¯ç”¨ï¼Œæ— æ³•æ›´æ–°æ­Œè¯');
        return;
      }
      
      // åªæ›´æ–°æ­Œè¯ï¼Œä¿æŒå…¶ä»–å…ƒæ•°æ®ä¸å˜
      await this.updateLyricsOnly(lyrics || '');
      
      hilog.info(DOMAIN, TAG, `Lyrics updated: ${lyrics ? lyrics.length : 0} characters`);
      this.addDebugMessage(`âœ… æ­Œè¯æ›´æ–°æˆåŠŸ: ${lyrics ? lyrics.length : 0} å­—ç¬¦`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to handle lyrics update: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ æ­Œè¯æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // ä»…æ›´æ–°æ’­æ”¾ä½ç½®ï¼Œä¸å½±å“å…¶ä»–çŠ¶æ€
  private async updatePositionOnly(positionInSeconds: number): Promise<void> {
    if (!this.session) return;
    
    try {
      // æ ¹æ®æ’­æ”¾åˆ—è¡¨çŠ¶æ€ç¡®å®šå¾ªç¯æ¨¡å¼
      let loopMode = avSession.LoopMode.LOOP_MODE_SEQUENCE;
      if (this.playlistLength <= 1) {
        loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
      } else if (!this.hasNextSong && !this.hasPreviousSong) {
        loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
      }

      // ä¿æŒå½“å‰æ’­æ”¾çŠ¶æ€ï¼Œåªæ›´æ–°ä½ç½®
      const playbackState: avSession.AVPlaybackState = {
        state: this.isPlaying ? avSession.PlaybackState.PLAYBACK_STATE_PLAY : avSession.PlaybackState.PLAYBACK_STATE_PAUSE,
        loopMode: loopMode,
        isFavorite: false,
        position: {
          elapsedTime: Math.floor(positionInSeconds * 1000), // è½¬æ¢ä¸ºæ¯«ç§’
          updateTime: Date.now()
        }
      };
      
      await this.session.setAVPlaybackState(playbackState);
      hilog.info(DOMAIN, TAG, `Position updated: ${positionInSeconds.toFixed(1)}s`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update position only: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ ä½ç½®æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // æ›´æ–°æ’­æ”¾åˆ—è¡¨çŠ¶æ€
  private async updatePlaylistState(params: Record<string, ESObject>): Promise<void> {
    try {
      const oldHasNext = this.hasNextSong;
      const oldHasPrevious = this.hasPreviousSong;
      
      this.currentPlaylistIndex = (params.currentIndex as number) || -1;
      this.playlistLength = (params.playlistLength as number) || 0;
      this.hasNextSong = (params.hasNext as boolean) || false;
      this.hasPreviousSong = (params.hasPrevious as boolean) || false;
      
      this.addDebugMessage(`ğŸ“‹ æ’­æ”¾åˆ—è¡¨çŠ¶æ€æ›´æ–°: å½“å‰${this.currentPlaylistIndex + 1}/${this.playlistLength}, ä¸Šä¸€é¦–:${this.hasPreviousSong}, ä¸‹ä¸€é¦–:${this.hasNextSong}`);
      
      // æ’­æ”¾åˆ—è¡¨çŠ¶æ€å˜åŒ–æ—¶ï¼Œåªæ›´æ–°å¾ªç¯æ¨¡å¼ï¼Œä¸é‡å¤è®¾ç½®æ’­æ”¾çŠ¶æ€
      if (this.session && this.isSessionActive && 
          (oldHasNext !== this.hasNextSong || oldHasPrevious !== this.hasPreviousSong)) {
        
        // åªæ›´æ–°å¾ªç¯æ¨¡å¼ï¼Œä¿æŒå½“å‰æ’­æ”¾çŠ¶æ€å’Œä½ç½®
        await this.updateLoopModeOnly();
        
        this.addDebugMessage('ğŸ”„ æ’­æ”¾åˆ—è¡¨çŠ¶æ€å˜åŒ–ï¼Œä»…æ›´æ–°å¾ªç¯æ¨¡å¼');
        hilog.info(DOMAIN, TAG, `Playlist state changed: hasNext=${this.hasNextSong}, hasPrevious=${this.hasPreviousSong}`);
      }
      
      hilog.info(DOMAIN, TAG, `Playlist state updated: index=${this.currentPlaylistIndex}, length=${this.playlistLength}, hasNext=${this.hasNextSong}, hasPrevious=${this.hasPreviousSong}`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update playlist state: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ æ’­æ”¾åˆ—è¡¨çŠ¶æ€æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // ä»…æ›´æ–°å¾ªç¯æ¨¡å¼ï¼Œä¸å½±å“æ’­æ”¾çŠ¶æ€å’Œä½ç½®
  private async updateLoopModeOnly(): Promise<void> {
    if (!this.session) return;
    
    try {
      // æ ¹æ®æ’­æ”¾åˆ—è¡¨çŠ¶æ€ç¡®å®šå¾ªç¯æ¨¡å¼
      let loopMode = avSession.LoopMode.LOOP_MODE_SEQUENCE;
      if (this.playlistLength <= 1) {
        loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
      } else if (!this.hasNextSong && !this.hasPreviousSong) {
        loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
      }

      // è·å–å½“å‰æ’­æ”¾çŠ¶æ€ï¼Œåªæ›´æ–°å¾ªç¯æ¨¡å¼
      const playbackState: avSession.AVPlaybackState = {
        state: this.isPlaying ? avSession.PlaybackState.PLAYBACK_STATE_PLAY : avSession.PlaybackState.PLAYBACK_STATE_PAUSE,
        loopMode: loopMode,
        isFavorite: false,
        position: {
          elapsedTime: Math.floor(this.currentPosition * 1000), // ä¿æŒå½“å‰ä½ç½®
          updateTime: Date.now()
        }
      };
      
      await this.session.setAVPlaybackState(playbackState);
      hilog.info(DOMAIN, TAG, `Loop mode updated: ${loopMode}, position preserved: ${this.currentPosition.toFixed(1)}s`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update loop mode: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ å¾ªç¯æ¨¡å¼æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // ä»…æ›´æ–°æ­Œè¯ï¼Œä¸å½±å“å…¶ä»–å…ƒæ•°æ®
  private async updateLyricsOnly(lyrics: string): Promise<void> {
    if (!this.session) return;
    
    try {
      // æ„å»ºå®Œæ•´çš„AVMetadataå¯¹è±¡ï¼Œä¿æŒç°æœ‰çš„å…ƒæ•°æ®ï¼Œåªæ›´æ–°æ­Œè¯
      const metadata: avSession.AVMetadata = {
        assetId: 'voicehub_web_player',
        title: this.currentSong || '',
        artist: this.currentArtist || '',
        album: '', // ä¿æŒç©ºå€¼ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰å­˜å‚¨ä¸“è¾‘ä¿¡æ¯
        writer: this.currentArtist || '',
        composer: this.currentArtist || '',
        duration: this.currentDuration, // ä¿æŒç°æœ‰çš„æ—¶é•¿ä¿¡æ¯
        description: `${this.currentSong || ''} - ${this.currentArtist || ''}`,
        lyric: lyrics, // æ›´æ–°æ­Œè¯
        previousAssetId: '',
        nextAssetId: ''
      };
      
      // å¦‚æœæœ‰å°é¢å›¾ç‰‡ï¼Œé‡æ–°åŠ è½½å¹¶è®¾ç½®
      if (this.currentCover && this.currentCover.trim() !== '') {
        try {
          const pixelMap = await this.loadCoverImage(this.currentCover);
          if (pixelMap) {
            metadata.mediaImage = pixelMap;
          }
        } catch (error) {
          hilog.warn(DOMAIN, TAG, `Failed to reload cover image for lyrics update: ${JSON.stringify(error)}`);
        }
      }
      
      await this.session.setAVMetadata(metadata);
      hilog.info(DOMAIN, TAG, `Lyrics only updated: ${lyrics.length} characters`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update lyrics only: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ ä»…æ­Œè¯æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // æ›´æ–°æ’­æ”¾çŠ¶æ€ï¼ˆå‚è€ƒMelotopiaé¡¹ç›®çš„åˆ†ç¦»å¼è®¾è®¡ï¼‰
  private async updatePlayState(isPlaying: boolean, position?: number, duration?: number): Promise<void> {
    try {
      const oldIsPlaying = this.isPlaying;
      this.isPlaying = isPlaying;
      
      // æ€»æ˜¯æ›´æ–°ä½ç½®ï¼Œå¦‚æœæœªæä¾›åˆ™ä½¿ç”¨å½“å‰ä½ç½®
      this.currentPosition = (position !== undefined && position >= 0) ? position : this.currentPosition;
      
      // åªåœ¨æ’­æ”¾çŠ¶æ€å˜åŒ–æ—¶è¾“å‡ºè¯¦ç»†æ—¥å¿—
      if (oldIsPlaying !== isPlaying) {
        this.addDebugMessage(`ğŸ”„ æ’­æ”¾çŠ¶æ€å˜åŒ–: ${oldIsPlaying ? 'æ’­æ”¾' : 'æš‚åœ'} â†’ ${isPlaying ? 'æ’­æ”¾' : 'æš‚åœ'} (ä½ç½®: ${this.currentPosition.toFixed(1)}s)`);
      }
      
      if (this.session) {
        // å¦‚æœå¼€å§‹æ’­æ”¾ï¼Œæ¿€æ´»AVSession
        if (isPlaying && !this.isSessionActive) {
          await this.activateAVSession();
        }
        
        // åªæ›´æ–°æ’­æ”¾çŠ¶æ€å’Œä½ç½®ï¼Œä¸å½±å“å·²è®¾ç½®çš„å…ƒæ•°æ®
        await this.setPlayStateWithPosition(isPlaying, this.currentPosition);
        
        // æš‚åœåç«‹å³æ›´æ–°ä½ç½®
        if (!isPlaying) {
          setTimeout(() => {
            this.updatePositionOnly(this.currentPosition);
          }, 100);
        }
        
        // åªåœ¨çŠ¶æ€å˜åŒ–æ—¶è¾“å‡ºæˆåŠŸæ—¥å¿—
        if (oldIsPlaying !== isPlaying) {
          this.addDebugMessage(`âœ… æ’­æ”¾çŠ¶æ€æ›´æ–°æˆåŠŸ: ${this.isPlaying ? 'æ’­æ”¾' : 'æš‚åœ'}, ä½ç½®: ${this.currentPosition.toFixed(1)}s`);
        }
        
      } else {
        hilog.warn(DOMAIN, TAG, 'No AVSession available for playback state update');
        this.addDebugMessage('âš ï¸ AVSessionä¸å¯ç”¨ï¼Œæ— æ³•æ›´æ–°æ’­æ”¾çŠ¶æ€');
      }
      
      hilog.info(DOMAIN, TAG, `Play state updated: ${this.isPlaying}, position: ${this.currentPosition}s, duration: ${duration}s`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update play state: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ æ’­æ”¾çŠ¶æ€æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // è®¾ç½®æ’­æ”¾çŠ¶æ€å’Œä½ç½®ï¼ˆå‚è€ƒMelotopiaçš„playStateå’ŒpauseStateæ–¹æ³•ï¼‰
  private async setPlayStateWithPosition(isPlaying: boolean, positionInSeconds: number): Promise<void> {
    if (!this.session) return;
    
    try {
      // æ ¹æ®æ’­æ”¾åˆ—è¡¨çŠ¶æ€ç¡®å®šå¾ªç¯æ¨¡å¼
      let loopMode = avSession.LoopMode.LOOP_MODE_SEQUENCE;
      if (this.playlistLength <= 1) {
        loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
      } else if (!this.hasNextSong && !this.hasPreviousSong) {
        loopMode = avSession.LoopMode.LOOP_MODE_SINGLE;
      }

      // å‚è€ƒMelotopiaçš„å®ç°ï¼ŒåŒæ—¶è®¾ç½®æ’­æ”¾çŠ¶æ€å’Œä½ç½®ä¿¡æ¯
      const playbackState: avSession.AVPlaybackState = {
        state: isPlaying ? avSession.PlaybackState.PLAYBACK_STATE_PLAY : avSession.PlaybackState.PLAYBACK_STATE_PAUSE,
        loopMode: loopMode,
        isFavorite: false,
        position: {
          elapsedTime: Math.floor(positionInSeconds * 1000), // è½¬æ¢ä¸ºæ¯«ç§’
          updateTime: Date.now()
        }
      };
      
      await this.session.setAVPlaybackState(playbackState);
      hilog.info(DOMAIN, TAG, `Play state set: ${isPlaying ? 'PLAY' : 'PAUSE'} at ${positionInSeconds.toFixed(1)}s with loop mode: ${loopMode}`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to set play state with position: ${JSON.stringify(error)}`);
      // ArkTSè¦æ±‚æŠ›å‡ºErrorç±»å‹ï¼Œå°†errorè½¬æ¢ä¸ºErrorå®ä¾‹
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error(`Failed to set play state with position: ${JSON.stringify(error)}`);
      }
    }
  }



  // æ›´æ–°åª’ä½“å…ƒæ•°æ®
  private async updateMetadata(params: Record<string, ESObject>): Promise<void> {
    if (!this.session) {
      hilog.warn(DOMAIN, TAG, 'No AVSession available for metadata update');
      return;
    }

    try {
      // è·å–æ–°çš„å…ƒæ•°æ®ä¿¡æ¯ï¼Œåªæœ‰åœ¨æä¾›æœ‰æ•ˆå€¼æ—¶æ‰æ›´æ–°
      let hasChanges = false;
      let newSong = this.currentSong;
      let newArtist = this.currentArtist;
      let newCover = this.currentCover;
      
      // åªæœ‰åœ¨æä¾›æœ‰æ•ˆå€¼ä¸”ä¸å½“å‰å€¼ä¸åŒæ—¶æ‰æ›´æ–°
      if (params.title && typeof params.title === 'string' && params.title.trim() !== '') {
        const titleValue = params.title.trim();
        if (this.currentSong !== titleValue) {
          newSong = titleValue;
          hasChanges = true;
        }
      } else if (!this.currentSong || (params.title === '' && this.currentSong !== '')) {
        // å¤„ç†åœæ­¢æ’­æ”¾æ—¶çš„æ¸…ç†
        newSong = params.title || '';
        hasChanges = true;
      }
      
      if (params.artist && typeof params.artist === 'string' && params.artist.trim() !== '') {
        const artistValue = params.artist.trim();
        if (this.currentArtist !== artistValue) {
          newArtist = artistValue;
          hasChanges = true;
        }
      } else if (!this.currentArtist || (params.artist === '' && this.currentArtist !== '')) {
        // å¤„ç†åœæ­¢æ’­æ”¾æ—¶çš„æ¸…ç†
        newArtist = params.artist || '';
        hasChanges = true;
      }
      
      // å¤„ç†å°é¢å›¾ç‰‡ï¼Œæ”¯æŒ cover å’Œ artwork ä¸¤ä¸ªå­—æ®µ
      const coverParam: string | undefined = (params.artwork as string) || (params.cover as string);
      if (coverParam !== undefined) {
        const coverValue: string = coverParam || '';
        if (this.currentCover !== coverValue) {
          newCover = coverValue;
          hasChanges = true;
        }
      }
      
      // å¦‚æœæ²¡æœ‰å®é™…å˜åŒ–ï¼Œè·³è¿‡æ›´æ–°
      if (!hasChanges) {
        this.addDebugMessage(`ğŸ”„ å…ƒæ•°æ®æ— å˜åŒ–ï¼Œè·³è¿‡æ›´æ–°: ${newSong || ''} - ${newArtist || ''}`);
        hilog.info(DOMAIN, TAG, `Metadata unchanged, skipping update: ${newSong || ''} by ${newArtist || ''}`);
        return;
      }

      // æ›´æ–°æœ¬åœ°çŠ¶æ€
      this.currentSong = newSong;
      this.currentArtist = newArtist;
      this.currentCover = newCover;
      
      // æ›´æ–°æ—¶é•¿ä¿¡æ¯ï¼ˆå¦‚æœæä¾›ï¼‰
      if (params.duration && typeof params.duration === 'number' && params.duration > 0) {
        this.currentDuration = Math.floor(params.duration * 1000); // è½¬æ¢ä¸ºæ¯«ç§’
      }

      hilog.info(DOMAIN, TAG, `Updating metadata: ${this.currentSong} by ${this.currentArtist}, cover: ${this.currentCover}`);
      this.addDebugMessage(`ğŸµ æ›´æ–°æ­Œæ›²å…ƒæ•°æ®: ${this.currentSong} - ${this.currentArtist}`);

      // ç¡®ä¿AVSessionå·²æ¿€æ´»
      if (!this.isSessionActive) {
        hilog.info(DOMAIN, TAG, 'AVSession not active, activating...');
        await this.activateAVSession();
      }

      // è®°å½•æ’­æ”¾åˆ—è¡¨çŠ¶æ€ - æ§åˆ¶èƒ½åŠ›ç”±ç›‘å¬å™¨è‡ªåŠ¨ç¡®å®š
      this.addDebugMessage(`ğŸ›ï¸ å…ƒæ•°æ®æ›´æ–°æ—¶æ’­æ”¾åˆ—è¡¨çŠ¶æ€: ä¸‹ä¸€é¦–=${this.hasNextSong}, ä¸Šä¸€é¦–=${this.hasPreviousSong}`);
      hilog.info(DOMAIN, TAG, `Metadata update with playlist state: hasNext=${this.hasNextSong}, hasPrevious=${this.hasPreviousSong}`);
      
      // åœ¨API 12ä¸­ï¼Œæ§åˆ¶èƒ½åŠ›ç”±æ³¨å†Œçš„ç›‘å¬å™¨è‡ªåŠ¨ç¡®å®šï¼Œæ— éœ€æ‰‹åŠ¨è®¾ç½®

      // æ„å»ºå®Œæ•´çš„AVMetadataå¯¹è±¡ï¼Œåªä½¿ç”¨å‰ç«¯ä¼ é€’çš„å®é™…æ•°æ®
      const finalTitle = this.currentSong || '';
      const finalArtist = this.currentArtist || '';
      const finalAlbum = (params.album as string) || '';
      
      // å¤„ç†æ­Œè¯ - æ·»åŠ è¯¦ç»†è°ƒè¯•ä¿¡æ¯
      const lyricsParam = params.lyrics as string;
      const finalLyrics = lyricsParam && typeof lyricsParam === 'string' ? lyricsParam : '';
      
      // è¯¦ç»†è®°å½•æ­Œè¯å¤„ç†è¿‡ç¨‹
      hilog.info(DOMAIN, TAG, `Lyrics processing: received param type=${typeof lyricsParam}, value=${lyricsParam ? lyricsParam.substring(0, 100) + '...' : 'null/undefined'}`);
      this.addDebugMessage(`ğŸ¤ æ­Œè¯å¤„ç†: æ¥æ”¶ç±»å‹=${typeof lyricsParam}, é•¿åº¦=${lyricsParam ? lyricsParam.length : 0}`);
      
      if (finalLyrics) {
        // æ£€æŸ¥æ­Œè¯å†…å®¹æ˜¯å¦åŒ…å«è‰ºæœ¯å®¶ä¿¡æ¯ï¼ˆå¯èƒ½çš„é”™è¯¯æ¥æºï¼‰
        const containsArtist = finalLyrics.includes(finalArtist);
        hilog.info(DOMAIN, TAG, `Final lyrics: length=${finalLyrics.length}, contains artist name=${containsArtist}`);
        this.addDebugMessage(`ğŸ¤ æœ€ç»ˆæ­Œè¯: é•¿åº¦=${finalLyrics.length}, åŒ…å«è‰ºæœ¯å®¶å=${containsArtist}`);
        
        // æ˜¾ç¤ºæ­Œè¯å‰å‡ è¡Œç”¨äºè°ƒè¯•
        const firstLines = finalLyrics.split('\r\n').slice(0, 3).join(' | ');
        hilog.info(DOMAIN, TAG, `Lyrics preview: ${firstLines}`);
        this.addDebugMessage(`ğŸ¤ æ­Œè¯é¢„è§ˆ: ${firstLines}`);
      }
      
      let metadata: avSession.AVMetadata = {
        assetId: 'voicehub_web_player',
        title: finalTitle,
        artist: finalArtist,
        album: finalAlbum,
        writer: finalArtist, // æ·»åŠ ä½œè¯è€…å­—æ®µ
        composer: finalArtist, // æ·»åŠ ä½œæ›²è€…å­—æ®µ
        duration: Math.floor(((params.duration as number) || 0) * 1000), // æ·»åŠ æ—¶é•¿å­—æ®µï¼ˆè½¬æ¢ä¸ºæ¯«ç§’ï¼‰
        description: `${finalTitle} - ${finalArtist}`, // æ·»åŠ æè¿°
        lyric: finalLyrics, // æ­Œè¯å­—æ®µ
        previousAssetId: '', // ä¸Šä¸€é¦–æ­Œæ›²ID
        nextAssetId: '' // ä¸‹ä¸€é¦–æ­Œæ›²ID
      };
      
      // è®°å½•å®Œæ•´çš„å…ƒæ•°æ®ä¿¡æ¯ç”¨äºè°ƒè¯•
      hilog.info(DOMAIN, TAG, `Complete metadata: title="${metadata.title}", artist="${metadata.artist}", lyric_length=${metadata.lyric ? metadata.lyric.length : 0}`);
      this.addDebugMessage(`ğŸ“‹ å®Œæ•´å…ƒæ•°æ®: æ ‡é¢˜="${metadata.title}", è‰ºæœ¯å®¶="${metadata.artist}", æ­Œè¯é•¿åº¦=${metadata.lyric ? metadata.lyric.length : 0}`);
      
      // è®°å½•æ­Œè¯ä¿¡æ¯
      if (finalLyrics) {
        hilog.info(DOMAIN, TAG, `Lyrics provided: ${finalLyrics.length} characters`);
        this.addDebugMessage(`ğŸ¤ æ­Œè¯å·²è®¾ç½®: ${finalLyrics.length} å­—ç¬¦`);
      } else {
        hilog.info(DOMAIN, TAG, 'No lyrics provided');
        this.addDebugMessage('ğŸ¤ æ— æ­Œè¯ä¿¡æ¯');
      }

      // å¦‚æœæœ‰å°é¢å›¾ç‰‡ï¼Œå¤„ç†å°é¢
      if (this.currentCover && this.currentCover.trim() !== '') {
        hilog.info(DOMAIN, TAG, `Loading cover image: ${this.currentCover}`);
        this.addDebugMessage(`ğŸ–¼ï¸ åŠ è½½å°é¢å›¾ç‰‡: ${this.currentCover.substring(0, 50)}...`);
        try {
          const pixelMap = await this.loadCoverImage(this.currentCover);
          if (pixelMap) {
            metadata.mediaImage = pixelMap;
            hilog.info(DOMAIN, TAG, 'Cover image added to metadata successfully');
            this.addDebugMessage('âœ… å°é¢å›¾ç‰‡åŠ è½½æˆåŠŸ');
          } else {
            hilog.warn(DOMAIN, TAG, 'Failed to load cover image - pixelMap is null');
            this.addDebugMessage('âš ï¸ å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥');
          }
        } catch (error) {
          hilog.warn(DOMAIN, TAG, `Failed to load cover image: ${JSON.stringify(error)}`);
          this.addDebugMessage(`âŒ å°é¢å›¾ç‰‡åŠ è½½å¼‚å¸¸: ${JSON.stringify(error)}`);
        }
      } else {
        hilog.info(DOMAIN, TAG, 'No cover image provided');
        this.addDebugMessage('â„¹ï¸ æ— å°é¢å›¾ç‰‡');
      }

      hilog.info(DOMAIN, TAG, `Setting complete metadata: ${JSON.stringify({
        assetId: metadata.assetId,
        title: metadata.title,
        artist: metadata.artist,
        album: metadata.album,
        duration: metadata.duration,
        description: metadata.description,
        hasImage: !!metadata.mediaImage
      })}`);

      await this.session.setAVMetadata(metadata);
      
      // å…ƒæ•°æ®æ›´æ–°åï¼Œç«‹å³æ›´æ–°æ’­æ”¾çŠ¶æ€å’Œä½ç½®ï¼ˆå‚è€ƒMelotopiaï¼‰
      setTimeout(async () => {
        await this.updatePlayState(this.isPlaying, this.currentPosition, params.duration as number);
      }, 100);
      
      hilog.info(DOMAIN, TAG, `Metadata updated successfully: ${this.currentSong} by ${this.currentArtist}`);
      this.addDebugMessage(`âœ… å…ƒæ•°æ®æ›´æ–°æˆåŠŸ: ${this.currentSong} - ${this.currentArtist}`);
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to update metadata: ${JSON.stringify(error)}`);
      this.addDebugMessage(`âŒ å…ƒæ•°æ®æ›´æ–°å¤±è´¥: ${JSON.stringify(error)}`);
    }
  }

  // åŠ è½½å°é¢å›¾ç‰‡ - åŸºäºåä¸ºå®˜æ–¹æ¡ˆä¾‹ä¼˜åŒ–
  private async loadCoverImage(coverUrl: string): Promise<image.PixelMap | null> {
    try {
      this.addDebugMessage(`ğŸŒ å¼€å§‹åŠ è½½å°é¢å›¾ç‰‡: ${coverUrl}`);
      
      if (coverUrl.startsWith('http://') || coverUrl.startsWith('https://')) {
        // ç½‘ç»œå›¾ç‰‡
        const httpRequest = http.createHttp();
        
        try {
          this.addDebugMessage('ğŸ“¡ åˆ›å»ºHTTPè¯·æ±‚...');
          // ä½¿ç”¨ç®€åŒ–çš„è¯·æ±‚é…ç½®ï¼Œå‚è€ƒåä¸ºå®˜æ–¹æ¡ˆä¾‹
          const response = await httpRequest.request(coverUrl, {
            method: http.RequestMethod.GET,
            expectDataType: http.HttpDataType.ARRAY_BUFFER,
            connectTimeout: 15000, // 15ç§’è¿æ¥è¶…æ—¶
            readTimeout: 30000,    // 30ç§’è¯»å–è¶…æ—¶
            header: {
              'User-Agent': 'Mozilla/5.0 (Linux; HarmonyOS) VoiceHub/1.0.0',
              'Accept': 'image/*,*/*;q=0.8'
            }
          });
          
          this.addDebugMessage(`ğŸ“Š HTTPå“åº”: çŠ¶æ€ç =${response.responseCode}, æ•°æ®å¤§å°=${response.result instanceof ArrayBuffer ? response.result.byteLength : 'unknown'}`);
          
          if (response.responseCode === 200 && response.result instanceof ArrayBuffer && response.result.byteLength > 0) {
            try {
              this.addDebugMessage(`ğŸ–¼ï¸ åˆ›å»ºImageSourceï¼Œæ•°æ®å¤§å°: ${response.result.byteLength} bytes`);
              
              // ç›´æ¥ä½¿ç”¨ArrayBufferåˆ›å»ºImageSourceï¼Œå‚è€ƒåä¸ºå®˜æ–¹æ¡ˆä¾‹
              const imageSource = image.createImageSource(response.result);
              
              // ä½¿ç”¨åä¸ºå®˜æ–¹æ¡ˆä¾‹æ¨èçš„DecodingOptionsé…ç½®
                const decodingOptions: image.DecodingOptions = {
                  // æ˜¯å¦å¯ç¼–è¾‘
                  editable: false,
                  // åƒç´ æ ¼å¼ï¼šRGBA_8888 (å‚è€ƒå®˜æ–¹æ¡ˆä¾‹)
                  desiredPixelFormat: image.PixelMapFormat.RGBA_8888,
                  // åˆ›å»ºå›¾ç‰‡å¤§å° - è®¾ç½®ä¸ºåˆç†çš„å°é¢å°ºå¯¸
                  desiredSize: { height: 300, width: 300 }
                };
              
              this.addDebugMessage('ğŸ”„ ä½¿ç”¨åä¸ºå®˜æ–¹æ¨èé…ç½®åˆ›å»ºPixelMap...');
              
              // ä½¿ç”¨å®˜æ–¹æ¡ˆä¾‹çš„æ–¹å¼åˆ›å»ºPixelMap
              const pixelMap = await imageSource.createPixelMap(decodingOptions);
              
              if (pixelMap) {
                this.addDebugMessage('âœ… å°é¢å›¾ç‰‡åŠ è½½æˆåŠŸï¼');
                httpRequest.destroy();
                return pixelMap;
              } else {
                this.addDebugMessage('âŒ PixelMapåˆ›å»ºè¿”å›null');
                
                // å¤‡ç”¨ç­–ç•¥ï¼šå°è¯•ä¸æŒ‡å®šsize
                 try {
                    this.addDebugMessage('ğŸ”„ å¤‡ç”¨ç­–ç•¥ï¼šå°è¯•ä¸æŒ‡å®šå°ºå¯¸...');
                    const backupOptions: image.DecodingOptions = {
                      editable: false,
                      desiredPixelFormat: image.PixelMapFormat.RGBA_8888
                    };
                  const backupPixelMap = await imageSource.createPixelMap(backupOptions);
                  if (backupPixelMap) {
                    this.addDebugMessage('âœ… å¤‡ç”¨ç­–ç•¥æˆåŠŸï¼');
                    httpRequest.destroy();
                    return backupPixelMap;
                  }
                } catch (backupError) {
                  this.addDebugMessage(`âŒ å¤‡ç”¨ç­–ç•¥å¤±è´¥: ${JSON.stringify(backupError)}`);
                }
                
                httpRequest.destroy();
                return null;
              }
            } catch (imageError) {
              this.addDebugMessage(`âŒ ImageSourceå¤„ç†å¤±è´¥: ${JSON.stringify(imageError)}`);
              httpRequest.destroy();
              
              // å¦‚æœä¸»è¦æ–¹æ³•å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨æ–¹æ³•
              this.addDebugMessage('ğŸ”„ å°è¯•å¤‡ç”¨åŠ è½½æ–¹æ³•...');
              return await this.loadCoverImageAlternative(coverUrl);
            }
          } else {
            this.addDebugMessage(`âš ï¸ æ— æ•ˆå“åº”: çŠ¶æ€ç =${response.responseCode}, æœ‰æ•°æ®=${response.result instanceof ArrayBuffer}, å¤§å°=${response.result instanceof ArrayBuffer ? response.result.byteLength : 'N/A'}`);
            httpRequest.destroy();
            
            // å°è¯•å¤‡ç”¨æ–¹æ¡ˆ
            if (response.responseCode === 403 || response.responseCode === 404) {
              this.addDebugMessage('ğŸ”„ å°è¯•å¤‡ç”¨è¯·æ±‚æ–¹æ³•...');
              return await this.loadCoverImageAlternative(coverUrl);
            }
            
            return null;
          }
        } catch (httpError) {
          this.addDebugMessage(`âŒ HTTPè¯·æ±‚å¤±è´¥: ${JSON.stringify(httpError)}`);
          httpRequest.destroy();
          return null;
        }
      } else if (coverUrl.startsWith('/')) {
        // æœ¬åœ°èµ„æº
        try {
          this.addDebugMessage(`ğŸ“ åŠ è½½æœ¬åœ°å›¾ç‰‡: ${coverUrl}`);
          const imageSource = image.createImageSource(coverUrl);
          
          // å¯¹æœ¬åœ°å›¾ç‰‡ä¹Ÿä½¿ç”¨ç›¸åŒçš„é…ç½®
            const localOptions: image.DecodingOptions = {
              editable: false,
              desiredPixelFormat: image.PixelMapFormat.RGBA_8888,
              desiredSize: { height: 300, width: 300 }
            };
          
          const pixelMap = await imageSource.createPixelMap(localOptions);
          
          if (pixelMap) {
            this.addDebugMessage('âœ… æœ¬åœ°å°é¢å›¾ç‰‡åŠ è½½æˆåŠŸ');
            return pixelMap;
          } else {
            this.addDebugMessage('âŒ æœ¬åœ°PixelMapåˆ›å»ºè¿”å›null');
            return null;
          }
        } catch (localError) {
          this.addDebugMessage(`âŒ æœ¬åœ°å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥: ${JSON.stringify(localError)}`);
          return null;
        }
      }
      
      this.addDebugMessage(`âš ï¸ ä¸æ”¯æŒçš„å°é¢URLæ ¼å¼: ${coverUrl}`);
      return null;
    } catch (error) {
      this.addDebugMessage(`âŒ å°é¢å›¾ç‰‡åŠ è½½å¤±è´¥: ${JSON.stringify(error)}`);
      return null;
    }
  }



  // å¤‡ç”¨å°é¢å›¾ç‰‡åŠ è½½æ–¹æ³• - ä½¿ç”¨åä¸ºå®˜æ–¹æ¨èé…ç½®
  private async loadCoverImageAlternative(coverUrl: string): Promise<image.PixelMap | null> {
    try {
      this.addDebugMessage(`ğŸ”„ ä½¿ç”¨å¤‡ç”¨æ–¹æ³•åŠ è½½å°é¢å›¾ç‰‡: ${coverUrl}`);
      
      const httpRequest = http.createHttp();
      
      try {
        this.addDebugMessage('ğŸ“¡ åˆ›å»ºå¤‡ç”¨HTTPè¯·æ±‚ï¼ˆç®€åŒ–é…ç½®ï¼‰...');
        // ä½¿ç”¨ç®€åŒ–çš„è¯·æ±‚é…ç½®
        const response = await httpRequest.request(coverUrl, {
          method: http.RequestMethod.GET,
          expectDataType: http.HttpDataType.ARRAY_BUFFER,
          connectTimeout: 10000,
          readTimeout: 15000,
          header: {
            'User-Agent': 'VoiceHub/1.0.0',
            'Accept': 'image/*,*/*;q=0.8'
          }
        });
        
        this.addDebugMessage(`ğŸ“Š å¤‡ç”¨è¯·æ±‚å“åº”: çŠ¶æ€ç =${response.responseCode}`);
        
        if (response.responseCode === 200 && response.result instanceof ArrayBuffer && response.result.byteLength > 0) {
          try {
            this.addDebugMessage(`ğŸ–¼ï¸ å¤‡ç”¨æ–¹æ³•åˆ›å»ºImageSourceï¼Œæ•°æ®å¤§å°: ${response.result.byteLength} bytes`);
            const imageSource = image.createImageSource(response.result);
            
            // ä½¿ç”¨ä¸ä¸»æ–¹æ³•ç›¸åŒçš„åä¸ºå®˜æ–¹æ¨èé…ç½®
             const decodingOptions: image.DecodingOptions = {
               editable: false,
               desiredPixelFormat: image.PixelMapFormat.RGBA_8888,
               desiredSize: { height: 200, width: 200 } // å¤‡ç”¨æ–¹æ³•ä½¿ç”¨ç¨å°çš„å°ºå¯¸
             };
            
            this.addDebugMessage('ğŸ”„ å¤‡ç”¨æ–¹æ³•ä½¿ç”¨å®˜æ–¹é…ç½®åˆ›å»ºPixelMap...');
            const pixelMap = await imageSource.createPixelMap(decodingOptions);
            
            if (pixelMap) {
              this.addDebugMessage('âœ… å¤‡ç”¨æ–¹æ³•å°é¢å›¾ç‰‡åŠ è½½æˆåŠŸ');
              httpRequest.destroy();
              return pixelMap;
            } else {
              this.addDebugMessage('âŒ å¤‡ç”¨æ–¹æ³•PixelMapåˆ›å»ºè¿”å›null');
              
              // æœ€åå°è¯•ï¼šä¸æŒ‡å®šå°ºå¯¸
               try {
                  this.addDebugMessage('ğŸ”„ å¤‡ç”¨æ–¹æ³•æœ€åå°è¯•ï¼šä¸æŒ‡å®šå°ºå¯¸...');
                  const finalOptions: image.DecodingOptions = {
                    editable: false,
                    desiredPixelFormat: image.PixelMapFormat.RGBA_8888
                  };
                const finalPixelMap = await imageSource.createPixelMap(finalOptions);
                if (finalPixelMap) {
                  this.addDebugMessage('âœ… å¤‡ç”¨æ–¹æ³•æœ€åå°è¯•æˆåŠŸï¼');
                  httpRequest.destroy();
                  return finalPixelMap;
                }
              } catch (finalError) {
                this.addDebugMessage(`âŒ å¤‡ç”¨æ–¹æ³•æœ€åå°è¯•å¤±è´¥: ${JSON.stringify(finalError)}`);
              }
              
              httpRequest.destroy();
              return null;
            }
          } catch (imageError) {
            this.addDebugMessage(`âŒ å¤‡ç”¨æ–¹æ³•å›¾ç‰‡å¤„ç†å¤±è´¥: ${JSON.stringify(imageError)}`);
            httpRequest.destroy();
            return null;
          }
        } else {
          this.addDebugMessage(`âŒ å¤‡ç”¨æ–¹æ³•æ— æ•ˆå“åº”: çŠ¶æ€ç =${response.responseCode}`);
          httpRequest.destroy();
          return null;
        }
      } catch (httpError) {
        this.addDebugMessage(`âŒ å¤‡ç”¨HTTPè¯·æ±‚å¤±è´¥: ${JSON.stringify(httpError)}`);
        httpRequest.destroy();
        return null;
      }
    } catch (error) {
      this.addDebugMessage(`âŒ å¤‡ç”¨å°é¢åŠ è½½å¤±è´¥: ${JSON.stringify(error)}`);
      return null;
    }
  }

  build() {
    Column() {
      // é¡¶éƒ¨çŠ¶æ€æ 
      Row() {
        Text('VoiceHub')
          .fontSize(18)
          .fontWeight(FontWeight.Bold)
          .fontColor('#ffffff')
        
        Blank()
        
        if (this.isPlaying && this.currentSong) {
          Row() {
            Text('â™ª')
              .fontSize(16)
              .fontColor('#4CAF50')
              .margin({ right: 4 })
            Column() {
              Text(this.currentSong)
                .fontSize(12)
                .fontColor('#ffffff')
                .maxLines(1)
                .textOverflow({ overflow: TextOverflow.Ellipsis })
                .width('100%')
              if (this.currentArtist) {
                Text(this.currentArtist)
                  .fontSize(10)
                  .fontColor('#cccccc')
                  .maxLines(1)
                  .textOverflow({ overflow: TextOverflow.Ellipsis })
                  .width('100%')
                  .margin({ top: 2 })
              }
            }
            .alignItems(HorizontalAlign.Start)
            .layoutWeight(1)
          }
          .layoutWeight(1)
          .margin({ left: 16, right: 16 })
          .alignItems(VerticalAlign.Center)
        }
        
        // æŒ‰é’®ç»„
        Row() {
          // åˆ·æ–°é¡µé¢æŒ‰é’®
          Button('åˆ·æ–°é¡µé¢')
            .fontSize(12)
            .padding({ left: 8, right: 8, top: 4, bottom: 4 })
            .backgroundColor('#2196F3')
            .fontColor('#ffffff')
            .borderRadius(4)
            .margin({ right: 8 })
            .onClick(() => {
              this.addDebugMessage('ğŸ”„ æ‰‹åŠ¨åˆ·æ–°ç½‘é¡µé¡µé¢...');
              this.isLoading = true;
              this.loadProgress = 0;
              // å…ˆå°è¯•åˆ·æ–°ï¼Œå¦‚æœå¤±è´¥åˆ™é‡æ–°åŠ è½½URL
              try {
                this.webController.refresh();
              } catch (error) {
                this.addDebugMessage('âš ï¸ åˆ·æ–°å¤±è´¥ï¼Œå°è¯•é‡æ–°åŠ è½½URL...');
                this.webController.loadUrl(this.currentUrl);
              }
            })
          
          // è°ƒè¯•ä¿¡æ¯å¼€å…³æŒ‰é’®
          Button('è°ƒè¯•ä¿¡æ¯')
            .fontSize(12)
            .padding({ left: 8, right: 8, top: 4, bottom: 4 })
            .backgroundColor(this.showDebugInfo ? '#FF9800' : '#666666')
            .fontColor('#ffffff')
            .borderRadius(4)
            .onClick(() => {
              this.showDebugInfo = !this.showDebugInfo;
              if (this.showDebugInfo) {
                this.addDebugMessage('ğŸ”§ è°ƒè¯•ä¿¡æ¯æ˜¾ç¤ºå·²å¼€å¯');
              }
            })
        }
      }
      .width('100%')
      .height(56)
      .padding({ left: 16, right: 16 })
      .backgroundColor('#1a1a1a')
      .justifyContent(FlexAlign.SpaceBetween)
      .alignItems(VerticalAlign.Center)

      // åŠ è½½è¿›åº¦æ¡
      if (this.isLoading) {
        Progress({ value: this.loadProgress, total: 100, type: ProgressType.Linear })
          .width('100%')
          .height(2)
          .color('#4CAF50')
      }

      // è°ƒè¯•ä¿¡æ¯æ˜¾ç¤ºåŒºåŸŸ
      if (this.showDebugInfo && this.debugMessages.length > 0) {
        Column() {
          Row() {
            Text('è°ƒè¯•ä¿¡æ¯:')
              .fontSize(14)
              .fontColor('#ffffff')
              .fontWeight(FontWeight.Bold)
            
            Blank()
            
            Button('æ¸…é™¤æ—¥å¿—')
              .fontSize(12)
              .padding({ left: 8, right: 8, top: 4, bottom: 4 })
              .backgroundColor('#666666')
              .fontColor('#ffffff')
              .borderRadius(4)
              .onClick(() => {
                this.clearDebugMessages();
              })
          }
          .width('100%')
          .margin({ bottom: 8 })
          
          Scroll() {
            Column() {
              ForEach(this.debugMessages, (message: string, index: number) => {
                Text(message)
                  .fontSize(11)
                  .fontColor('#cccccc')
                  .width('100%')
                  .textAlign(TextAlign.Start)
                  .margin({ bottom: 4 })
                  .padding({ left: 4, right: 4, top: 2, bottom: 2 })
                  .backgroundColor(index % 2 === 0 ? '#333333' : '#2a2a2a')
                  .borderRadius(2)
              }, (message: string, index: number) => `debug_${index}`)
            }
            .alignItems(HorizontalAlign.Start)
          }
          .scrollable(ScrollDirection.Vertical)
          .scrollBar(BarState.Auto)
          .height(150)
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: 8, bottom: 8 })
        .backgroundColor('#1a1a1a')
        .borderRadius(8)
        .margin({ left: 8, right: 8, bottom: 8 })
      }

      // å†…å®¹åŒºåŸŸ - WebViewæ˜¾ç¤ºå®Œæ•´ç½‘ç«™
      Web({ src: this.currentUrl, controller: this.webController })
        .layoutWeight(1)
        .width('100%')
        .javaScriptAccess(true)
        .domStorageAccess(true)
        .fileAccess(true)
        .imageAccess(true)
        .onlineImageAccess(true)
        .databaseAccess(true)
        .geolocationAccess(false)
        .mixedMode(MixedMode.All)
        .cacheMode(CacheMode.Default)
        .userAgent('VoiceHub-HarmonyOS/1.0.0 (HarmonyOS; Mobile) Mozilla/5.0 (Linux; Android 10; HarmonyOS) AppleWebKit/537.36')
        .onProgressChange((event) => {
          this.loadProgress = event?.newProgress || 0;
          this.addDebugMessage(`ğŸ“Š é¡µé¢åŠ è½½è¿›åº¦: ${this.loadProgress}%`);
        })
        .onPageBegin((event) => {
          this.addDebugMessage(`ğŸŒ å¼€å§‹åŠ è½½é¡µé¢: ${event?.url || 'unknown'}`);
          this.isLoading = true;
        })
        .onPageEnd(() => {
          this.onPageEnd();
        })
        .onErrorReceive((event) => {
          const errorInfo = event?.error?.getErrorInfo();
          const errorCode = event?.error?.getErrorCode();
          hilog.error(DOMAIN, TAG, `WebView error: ${errorInfo}, code: ${errorCode}`);
          this.addDebugMessage(`âŒ WebView é”™è¯¯: ${errorInfo} (ä»£ç : ${errorCode})`);
        })
        .onHttpErrorReceive((event) => {
          const statusCode = event?.response?.getResponseCode();
          const url = event?.request?.getRequestUrl();
          hilog.error(DOMAIN, TAG, `HTTP error: ${statusCode} for ${url}`);
          this.addDebugMessage(`âŒ HTTP é”™è¯¯: ${statusCode} - ${url}`);
        })
        .onSslErrorReceive((event) => {
          hilog.error(DOMAIN, TAG, `SSL error: ${JSON.stringify(event)}`);
          this.addDebugMessage(`âŒ SSL é”™è¯¯: ${JSON.stringify(event)}`);
        })
        .javaScriptProxy({
          object: {
            onMessage: (message: string): void => {
              this.onMessage(message);
            }
          },
          name: 'harmonyos',
          methodList: ['onMessage'],
          controller: this.webController
        })
      .layoutWeight(1)
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#000000')
  }
}